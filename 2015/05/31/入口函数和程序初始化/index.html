<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>入口函数和程序初始化 | ylw Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="程序的入口函数，站在程序员的角度来说，往往会认为程序是从main函数来开始执行的，可是有一个问题是，那么main函数是由谁调用的呢？我们知道，在C++中全局变量的构造函数是在调用main之前就已经被调用构造函数而初始化完毕，那么这个机制是如何实现的？
我们知道在shell脚本中执行一个程序，shell会接收输入的命令，利用fork()函数生成一个子进程，然后等待子进程运行完程序后返回。那么fork">
<meta property="og:type" content="article">
<meta property="og:title" content="入口函数和程序初始化">
<meta property="og:url" content="http://ylwhere.tk/2015/05/31/入口函数和程序初始化/index.html">
<meta property="og:site_name" content="ylw Home">
<meta property="og:description" content="程序的入口函数，站在程序员的角度来说，往往会认为程序是从main函数来开始执行的，可是有一个问题是，那么main函数是由谁调用的呢？我们知道，在C++中全局变量的构造函数是在调用main之前就已经被调用构造函数而初始化完毕，那么这个机制是如何实现的？
我们知道在shell脚本中执行一个程序，shell会接收输入的命令，利用fork()函数生成一个子进程，然后等待子进程运行完程序后返回。那么fork">
<meta property="og:image" content="http://ylwhere.tk/img/blog/fork.PNG">
<meta property="og:updated_time" content="2015-05-31T07:53:15.131Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="入口函数和程序初始化">
<meta name="twitter:description" content="程序的入口函数，站在程序员的角度来说，往往会认为程序是从main函数来开始执行的，可是有一个问题是，那么main函数是由谁调用的呢？我们知道，在C++中全局变量的构造函数是在调用main之前就已经被调用构造函数而初始化完毕，那么这个机制是如何实现的？
我们知道在shell脚本中执行一个程序，shell会接收输入的命令，利用fork()函数生成一个子进程，然后等待子进程运行完程序后返回。那么fork">
  
    <link rel="alternative" href="/atom.xml" title="ylw Home" type="application/atom+xml">
  
  
    <link rel="icon" href="img/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63335629-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="/img/favicon.png" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ylw Home</a></h1>
		</hgroup>

		
		<p class="header-subtitle">More Code More Confidence</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/About">ABOUT ME</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/ylwdream" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/ylwhere" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/wang-yu-lin-74" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/C-C/" style="font-size: 12.5px;">C/C++</a> <a href="/tags/MPI/" style="font-size: 17.5px;">MPI</a> <a href="/tags/Octopress/" style="font-size: 10px;">Octopress</a> <a href="/tags/compiler/" style="font-size: 10px;">compiler</a> <a href="/tags/io/" style="font-size: 12.5px;">io</a> <a href="/tags/llvm/" style="font-size: 10px;">llvm</a> <a href="/tags/memory/" style="font-size: 15px;">memory</a> <a href="/tags/octopress/" style="font-size: 10px;">octopress</a> <a href="/tags/pthread/" style="font-size: 10px;">pthread</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/socket/" style="font-size: 20px;">socket</a> <a href="/tags/tree/" style="font-size: 10px;">tree</a> <a href="/tags/爬虫/" style="font-size: 17.5px;">爬虫</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">friends的博客</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ylw Home</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/favicon.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ylw Home</h1>
			</hgroup>
			
			<p class="header-subtitle">More Code More Confidence</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/About">ABOUT ME</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ylwdream" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/ylwhere" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/wang-yu-lin-74" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-入口函数和程序初始化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/31/入口函数和程序初始化/" class="article-date">
  	<time datetime="2015-05-31T02:22:56.000Z" itemprop="datePublished">2015-05-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      入口函数和程序初始化
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/compiler/">compiler</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/linux/">linux</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      

          <!-- 文章目录开始 -->

          
            <div id="toc" class="toc-article">
            <strong class="toc-title">contents</strong>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#fork_函数"><span class="toc-number">1.</span> <span class="toc-text">fork 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的装载"><span class="toc-number">2.</span> <span class="toc-text">程序的装载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序入口函数"><span class="toc-number">3.</span> <span class="toc-text">程序入口函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
          </div>
          

          <!-- 文章目录结束 -->
        <p>程序的入口函数，站在程序员的角度来说，往往会认为程序是从main函数来开始执行的，可是有一个问题是，那么main函数是由谁调用的呢？我们知道，在C++中全局变量的构造函数是在调用main之前就已经被调用构造函数而初始化完毕，那么这个机制是如何实现的？</p>
<p>我们知道在shell脚本中执行一个程序，shell会接收输入的命令，利用<code>fork()</code>函数生成一个子进程，然后等待子进程运行完程序后返回。那么<code>fork()</code>函数又是怎么实现的，和程序的装载运行有什么关系？</p>
<a id="more"></a>
<h2 id="fork_函数">fork 函数</h2><p>先从<code>fork()</code>函数说起，它默认会创建一个新的进程，在父进程中返回值为子进程的pid，在子进程中返回的是0。</p>
<p>其实是子进程使用了和父进程一样的页表，导致两个进程所有数据都是一模一样的，没有任何差别。当然，在子进程的页表里会有特殊标记，使得当子进程需要写这段内存时（读的时候任何事情都不会发生），内核会将要写的这一页复制一份新的给子进程。是谓「写时复制」。</p>
<blockquote>
<p>利用<code>man fork</code> 可以看到下面的解释。</p>
</blockquote>
<p><img src="/img/blog/fork.PNG" alt=""></p>
<p>可以看到fork是对父进程的复制，只是一些锁、等待队列等不一样。<br>那么返回值为什么在父子进程中不一样的。</p>
<p>“引用一位网友的话来解释fpid的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0.”</p>
<p>其实在linux中fork返回值的处理交给了一个do_fork的函数，这个函数根据传入的值，然后会分别在子进程和父进程中执行，从而返回两次不同的值，具体过程和上面所说的实现思想差不多。</p>
<p>可以参考如下的分析：<br><a href="http://blog.csdn.net/yunsongice/article/details/5508242" target="_blank" rel="external">do_fork() 详解</a></p>
<h2 id="程序的装载">程序的装载</h2><p><code>fork()</code> 创建一个新进程，然后新的进程调用<code>execve()</code>系统调用执行指定的 ELF 文件。<code>execve()</code>函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replace the current process, executing PATH with arguments ARGV and</span><br><span class="line"> environment ENVP.  ARGV and ENVP are terminated by NULL pointers. </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">execve</span> <span class="params">(__const <span class="keyword">char</span> *__path, <span class="keyword">char</span> *__const __argv[],</span><br><span class="line"> 				   <span class="keyword">char</span> *__const __envp[])</span> __THROW __<span class="title">nonnull</span> <span class="params">((1, 2)</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>在进入了<code>execve()</code> 系统调用后，Linux 内核就开始真正的装载工作。在内核中，<code>execve()</code>调用相应的入口函数是<code>sys_execve()</code>,在Porcess32.c文件中可以查找到。主要内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_execve</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">char</span> *filename;</span><br><span class="line"></span><br><span class="line">	filename = getname((<span class="keyword">char</span> __user *) regs-&gt;bx);</span><br><span class="line">	error = PTR_ERR(filename);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(filename))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	error = do_execve(filename,</span><br><span class="line">			(<span class="keyword">char</span> __user * __user *) regs-&gt;cx,</span><br><span class="line">			(<span class="keyword">char</span> __user * __user *) regs-&gt;dx,</span><br><span class="line">			regs);</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中———user是给编译器检查用的，这里可以理解为<code>#define __user</code>，定义为空。得到文件的目录位置然后调用<code>do_execve()</code>来解析filename。<br><code>pt_regs</code> 是寄存器的结构体。作为函数的参数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pt_regs &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> si;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> di;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ds;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> es;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> gs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> orig_ax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>do_execve()</code> 首先读取文件的前128字节。判断文件的类型和。Linux支持的文件格式不止ELF一种，还有a.out和“#！”开始的脚本程序。每种可执行文件的开头几个字节都很特殊，特别是开头的4个字节，常常作被称为魔数。比如ELF文件的开头4个字节为0x7F,’e’,’l’,’f’;而java的可执行文件格式的头4个字节为’c’,’a’,’f’,’e’;如果被执行的是脚本程序，那么开头往往是“#!/bin/sh”，这时候开头的两个字节’#’,’!’就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">char</span> * filename,</span><br><span class="line">	<span class="keyword">char</span> __user *__user *argv,</span><br><span class="line">	<span class="keyword">char</span> __user *__user *envp,</span><br><span class="line">	<span class="keyword">struct</span> pt_regs * regs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> linux_binprm *bprm;</span><br><span class="line">	<span class="keyword">struct</span> file *file;</span><br><span class="line">	<span class="keyword">struct</span> files_struct *displaced;</span><br><span class="line">	<span class="keyword">bool</span> clear_in_exec;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = unshare_files(&amp;displaced);             <span class="comment">//检查文件状态，displaced为NULL。</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_ret;</span><br><span class="line"></span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	bprm = kzalloc(<span class="keyword">sizeof</span>(*bprm), GFP_KERNEL);      <span class="comment">//用kzalloc分配空间。</span></span><br><span class="line">	<span class="keyword">if</span> (!bprm)</span><br><span class="line">		<span class="keyword">goto</span> out_files;</span><br><span class="line"></span><br><span class="line">	retval = prepare_bprm_creds(bprm);    			<span class="comment">//检测锁的状态，设置新process的key值</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">	retval = check_unsafe_exec(bprm);				<span class="comment">//检查是否可以安全的执行</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line">	clear_in_exec = retval;</span><br><span class="line">	current-&gt;in_execve = <span class="number">1</span>;							<span class="comment">/* Tell the LSMs that the process is doing an</span><br><span class="line">				 * execve */</span></span><br><span class="line"></span><br><span class="line">	file = open_exec(filename);						<span class="comment">//打开可执行文件</span></span><br><span class="line">	retval = PTR_ERR(file);							<span class="comment">//把file地址转换为long型</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file))								<span class="comment">//检测地址值是否合法</span></span><br><span class="line">		<span class="keyword">goto</span> out_unmark;</span><br><span class="line"></span><br><span class="line">	sched_exec();									<span class="comment">//调度策略，平衡每个等待运行的进程的机会</span></span><br><span class="line"></span><br><span class="line">	bprm-&gt;file = file;</span><br><span class="line">	bprm-&gt;filename = filename;</span><br><span class="line">	bprm-&gt;interp = filename;			</span><br><span class="line"></span><br><span class="line">	retval = bprm_mm_init(bprm);					<span class="comment">//创建一个暂时的栈空间</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_file;</span><br><span class="line"></span><br><span class="line">	bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);		<span class="comment">//计算argv参数的个数</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = bprm-&gt;argc) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);		<span class="comment">//环境变量的个数</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = bprm-&gt;envc) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = prepare_binprm(bprm);					<span class="comment">// Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);  <span class="comment">//拷贝参数到暂时的栈空间</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	bprm-&gt;exec = bprm-&gt;p;</span><br><span class="line">	retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	current-&gt;flags &amp;= ~PF_KTHREAD;</span><br><span class="line">	retval = search_binary_handler(bprm,regs);			<span class="comment">//判断魔数，调用相应的装载程序</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* execve succeeded */</span></span><br><span class="line">	current-&gt;fs-&gt;in_exec = <span class="number">0</span>;</span><br><span class="line">	current-&gt;in_execve = <span class="number">0</span>;</span><br><span class="line">	acct_update_integrals(current);</span><br><span class="line">	free_bprm(bprm);</span><br><span class="line">	<span class="keyword">if</span> (displaced)</span><br><span class="line">		put_files_struct(displaced);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看结构体,其中<code>BINPRM_BUF_SIZE = 128</code>可以在<code>binfmts.h (D:\开源代码\linux kernel\linux-2.6.32.65\include\linux)</code>查找到。    <code>search_binary_handler()</code>会通过判断文件头部的魔数来确定文件的格式，并且调用相应的装载处理过程。比如ELF可执行文件的装载处理过程叫做<code>load_elf_binary</code>;装载可执行脚本的处理过程为<code>load_script()</code>.<code>load_elf_binary</code>被定义在<code>fs/binfmt_elf.c</code>中。 它的主要步骤是：</p>
<ul>
<li>1.检测ELF可执行文件的有效性，比如魔数、程序头表中的数量。</li>
<li>2.寻找动态链接的“.interp” 段，设置动态链接器的路径。</li>
<li>3.根据ELF可执行文件的程序表头的描述，对ELF文件进行映射，比如代码，数据，只读数据</li>
<li>4.初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。</li>
<li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序的入口点就是ELF文件的e_entry所指的地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * This structure is used to hold the arguments that are used when loading binaries.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> linux_binprm&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[BINPRM_BUF_SIZE];</span><br><span class="line">	<span class="keyword">struct</span> vm_area_struct *vma;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vma_pages;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> mm_struct *mm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> p; <span class="comment">/* current top of mem */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">		cred_prepared:<span class="number">1</span>,<span class="comment">/* true if creds already prepared (multiple</span><br><span class="line">				 * preps happen for interpreters) */</span></span><br><span class="line">		cap_effective:<span class="number">1</span>;<span class="comment">/* true if has elevated effective capabilities,</span><br><span class="line">				 * false if not; except for init which inherits</span><br><span class="line">				 * its parent's caps anyway */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> recursion_depth;</span><br><span class="line">	<span class="keyword">struct</span> file * file;</span><br><span class="line">	<span class="keyword">struct</span> cred *cred;	<span class="comment">/* new credentials */</span></span><br><span class="line">	<span class="keyword">int</span> unsafe;		<span class="comment">/* how unsafe this exec is (mask of LSM_UNSAFE_*) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> per_clear;	<span class="comment">/* bits to clear in current-&gt;personality */</span></span><br><span class="line">	<span class="keyword">int</span> argc, envc;</span><br><span class="line">	<span class="keyword">char</span> * filename;	<span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line">	<span class="keyword">char</span> * interp;		<span class="comment">/* Name of the binary really executed. Most</span><br><span class="line">				   of the time same as filename, but could be</span><br><span class="line">				   different for binfmt_&#123;misc,script&#125; */</span></span><br><span class="line">	<span class="keyword">unsigned</span> interp_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> interp_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> loader, exec;</span><br></pre></td></tr></table></figure>
<p>当<code>load_elf_binary()</code>执行完毕，返回至<code>do_execve()</code>再返回至<code>sys_execve()</code>，上面的第5步中已经把系统调用的返回地址改为了被装载的ELf程序的入口地址了，所以EIP寄存器直接跳转到了ELF程序的入口地址。于是新的程序开始执行，ELF文件装载完毕。</p>
<blockquote>
<p>总结就是: <code>execve()--&gt;sys_execve()--&gt;do_execve()--&gt;search_binary_hander()-&gt;load_elf_binary()</code></p>
</blockquote>
<h2 id="程序入口函数">程序入口函数</h2><p>先看下面的一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> v;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> g = foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bye!"</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; g &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>用g++ -S test.c -o test.S</code> 可以得到下面的汇编指令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.LFE1020:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.type	_Z41__static_initialization_and_destruction_0ii, @function</span><br><span class="line">_Z41__static_initialization_and_destruction_0ii:</span><br><span class="line">.LFB1057:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">	.cfi_offset <span class="number">5</span>, -<span class="number">8</span></span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">5</span></span><br><span class="line">	subl	$<span class="number">8</span>, %esp</span><br><span class="line">	cmpl	$<span class="number">1</span>, <span class="number">8</span>(%ebp)</span><br><span class="line">	jne	.L6</span><br><span class="line">	cmpl	$<span class="number">65535</span>, <span class="number">12</span>(%ebp)</span><br><span class="line">	jne	.L6</span><br><span class="line">	subl	$<span class="number">12</span>, %esp</span><br><span class="line">	pushl	$v</span><br><span class="line">	call	_ZNSsC1Ev</span><br><span class="line">	addl	$<span class="number">16</span>, %esp</span><br><span class="line">	subl	$<span class="number">4</span>, %esp</span><br><span class="line">	pushl	$__dso_handle</span><br><span class="line">	pushl	$v</span><br><span class="line">	pushl	$_ZNSsD1Ev</span><br><span class="line">	call	__cxa_atexit</span><br><span class="line">	addl	$<span class="number">16</span>, %esp</span><br><span class="line">	subl	$<span class="number">12</span>, %esp</span><br><span class="line">	pushl	$_ZStL8__ioinit</span><br><span class="line">	call	_ZNSt8ios_base4InitC1Ev</span><br><span class="line">	addl	$<span class="number">16</span>, %esp</span><br><span class="line">	subl	$<span class="number">4</span>, %esp</span><br><span class="line">	pushl	$__dso_handle</span><br><span class="line">	pushl	$_ZStL8__ioinit</span><br><span class="line">	pushl	$_ZNSt8ios_base4InitD1Ev</span><br><span class="line">	call	__cxa_atexit</span><br><span class="line">	addl	$<span class="number">16</span>, %esp</span><br><span class="line">	call	_Z3foov</span><br><span class="line">	fstpl	g</span><br><span class="line">.L6:</span><br><span class="line">	leave</span><br><span class="line">	.cfi_restore <span class="number">5</span></span><br><span class="line">	.cfi_def_cfa <span class="number">4</span>, <span class="number">4</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure></p>
<p>可以看到汇编指令对于全局变量首先会注册到<code>_Z41__static_initialization_and_destruction_0ii</code>初始化。<br>glibc的程序入口为`_start（这个入口是由链接器的脚本所制定的）_start由汇编实现，并且和平台相关。<br>i386的_start实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the canonical entry point, usually the first thing in the text</span><br><span class="line">   segment.  The SVR4/i386 ABI (pages 3-31, 3-32) says that when the entry</span><br><span class="line">   point runs, most registers' values are unspecified, except for:</span><br><span class="line"></span><br><span class="line">   %edx		Contains a function pointer to be registered with `atexit'.</span><br><span class="line">		This is how the dynamic linker arranges to have DT_FINI</span><br><span class="line">		functions called for shared libraries that have been loaded</span><br><span class="line">		before this code runs.</span><br><span class="line"></span><br><span class="line">   %esp		The stack contains the arguments and environment:</span><br><span class="line">		0(%esp)			argc</span><br><span class="line">		4(%esp)			argv[0]</span><br><span class="line">		...</span><br><span class="line">		(4*argc)(%esp)		NULL</span><br><span class="line">		(4*(argc+1))(%esp)	envp[0]</span><br><span class="line">		...</span><br><span class="line">					NULL</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.globl _start</span><br><span class="line">	.type _start,@function</span><br><span class="line">_start:</span><br><span class="line">	<span class="comment">/* Clear the frame pointer.  The ABI suggests this be done, to mark</span><br><span class="line">	   the outermost frame obviously.  */</span></span><br><span class="line">	xorl %ebp, %ebp</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Extract the arguments as encoded on the stack and set up</span><br><span class="line">	   the arguments for `main': argc, argv.  envp will be determined</span><br><span class="line">	   later in __libc_start_main.  */</span></span><br><span class="line">	popl %esi		<span class="comment">/* Pop the argument count.  */</span></span><br><span class="line">	movl %esp, %ecx		<span class="comment">/* argv starts just at the current stack top.*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Before pushing the arguments align the stack to a 16-byte</span><br><span class="line">	(SSE needs 16-byte alignment) boundary to avoid penalties from</span><br><span class="line">	misaligned accesses.  Thanks to Edward Seidl &lt;seidl@janed.com&gt;</span><br><span class="line">	for pointing this out.  */</span></span><br><span class="line">	andl $<span class="number">0xfffffff0</span>, %esp</span><br><span class="line">	pushl %eax		<span class="comment">/* Push garbage because we allocate</span><br><span class="line">				   28 more bytes.  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Provide the highest stack address to the user code (for stacks</span><br><span class="line">	   which grow downwards).  */</span></span><br><span class="line">	pushl %esp</span><br><span class="line"></span><br><span class="line">	pushl %edx		<span class="comment">/* Push address of the shared library</span><br><span class="line">				   termination function.  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Push address of our own entry points to .fini and .init.  */</span></span><br><span class="line">	pushl $__libc_csu_fini</span><br><span class="line">	pushl $__libc_csu_init</span><br><span class="line"></span><br><span class="line">	pushl %ecx		<span class="comment">/* Push second argument: argv.  */</span></span><br><span class="line">	pushl %esi		<span class="comment">/* Push first argument: argc.  */</span></span><br><span class="line"></span><br><span class="line">	pushl $main</span><br><span class="line">	call __libc_start_main</span><br></pre></td></tr></table></figure></p>
<p>实际执行代码的函数是<code>__libc_start_main</code>,函数的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">STATIC <span class="keyword">int</span> <span class="title">LIBC_START_MAIN</span> <span class="params">(<span class="keyword">int</span> (*main)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> **, <span class="keyword">char</span> **</span><br><span class="line">					 MAIN_AUXVEC_DECL)</span>,</span><br><span class="line">			    <span class="keyword">int</span> argc,</span><br><span class="line">			    <span class="keyword">char</span> **argv,</span><br><span class="line">#ifdef LIBC_START_MAIN_AUXVEC_ARG</span><br><span class="line">			    <span class="title">ElfW</span><span class="params">(auxv_t)</span> *auxvec,</span><br><span class="line">#endif</span><br><span class="line">			    __<span class="title">typeof</span> <span class="params">(main)</span> init,</span><br><span class="line">			    <span class="title">void</span> <span class="params">(*fini)</span> <span class="params">(<span class="keyword">void</span>)</span>,</span><br><span class="line">			    <span class="title">void</span> <span class="params">(*rtld_fini)</span> <span class="params">(<span class="keyword">void</span>)</span>,</span><br><span class="line">			    <span class="keyword">void</span> *stack_end)</span><br><span class="line">     __<span class="title">attribute__</span> <span class="params">((noreturn)</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>一共有7个参数，其中main由第一个参数传入，紧接着是argc和argv，出了mian的函数指针外，外部还要传入3个函数指针，分别是：</p>
<ul>
<li>init：main 调用前的初始化工作</li>
<li>fini：main 结束后的收尾工作</li>
<li>rtld_fini: 和动态加载有关的收尾工作</li>
<li>最后的stack_end 标明了栈底的位置，即最高的栈位置。</li>
</ul>
<p>libc_start_main中的关键函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the thread library at least a bit since the libgcc</span><br><span class="line">   functions are using thread functions if these are available and</span><br><span class="line">   we need to setup errno.  */</span></span><br><span class="line">__pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call the initializer of the libc.  This is only needed here if we</span><br><span class="line">   are compiling for the static library in which case we haven't</span><br><span class="line">   run the constructors in `_dl_start_user'.  */</span></span><br><span class="line">__libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line"><span class="keyword">if</span> (fini)</span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) fini, NULL, NULL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line">  (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line">    <span class="comment">/* Run the program.  */</span></span><br><span class="line">    result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br></pre></td></tr></table></figure>
<p>在最后，main函数终于被调用，并退出。调用过程为<code>_start-&gt;_libc_start_main-&gt;exit-&gt;_exit</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.type	_exit,@function</span><br><span class="line">	.global	_exit</span><br><span class="line">_exit:</span><br><span class="line">	movl	<span class="number">4</span>(%esp), %ebx</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Not available.  Now the old one.  */</span></span><br><span class="line">	movl	$__NR_exit, %eax</span><br><span class="line">	<span class="comment">/* Don't bother using ENTER_KERNEL here.  If the exit_group</span><br><span class="line">	   syscall is not available AT_SYSINFO isn't either.  */</span></span><br><span class="line">	<span class="keyword">int</span>	$<span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This must not fail.  Be sure we don't return.  */</span></span><br><span class="line">	hlt</span><br></pre></td></tr></table></figure></p>
<p>可以知道_exit的作用仅仅是调用exit这个系统调用。也就是说_exit调用后，进程就会直接结束。程序正常结束有两种情况，一种是mian函数的正常返回，另一种是调用exit推出。在——libc_start_main中可以看到，即使main返回了，exit也会被调用。exit是进程正常退出的必经之路。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/yunsongice/article/details/5508242" target="_blank" rel="external">do_fork() 详解</a></li>
<li><a href="">程序员的自我修养</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/06/03/makefile-入门学习/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          makefile 入门学习
        
      </div>
    </a>
  
  
    <a href="/2015/05/24/linux-Dynamic-linking/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">linux Dynamic linking</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="入口函数和程序初始化" data-title="入口函数和程序初始化" data-url="http://ylwhere.tk/2015/05/31/入口函数和程序初始化/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>



</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 ylw Home
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63335629-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>