<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ylw Home]]></title>
  <subtitle><![CDATA[More Code More Confidence]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ylwhere.tk/"/>
  <updated>2015-09-08T11:58:14.481Z</updated>
  <id>http://ylwhere.tk/</id>
  
  <author>
    <name><![CDATA[ylw Home]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Lua 脚本的学习]]></title>
    <link href="http://ylwhere.tk/2015/09/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6-Lua/"/>
    <id>http://ylwhere.tk/2015/09/08/为什么学-Lua/</id>
    <published>2015-09-08T11:46:58.000Z</published>
    <updated>2015-09-08T11:58:14.481Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么学_Lua">为什么学 Lua</h2><p>其实我是不想学习的，应为对脚本语言这么“开放”的语法一直感觉很不规范。但是由于工作需要，不得不开始学习lua。我想说第一眼看上去lua和python的数据类型和语法规则简直真相（因为我刚看了一点python）。好了，至于lua有什么用？一般看网上说是为了支持游戏脚本。lua怎么说？应该是一个胶水吧？把各种语言穿起来。lua完全符合ANSI 的C语言规范。也就是可以直接用c编译器编译了。</p>
<a id="more"></a>
<h2 id="lua_的特性">lua 的特性</h2><p>lua 可以返回多个结果。这个是C/C++语言做不到的，第一眼我就震惊了。（后面有更震惊的事情，可以把函数当变量用、以及闭包）。我觉得lua简直是把ak47.用起来肯定威力巨大。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">	<span class="keyword">local</span> mi = <span class="number">1</span> <span class="comment">-- maximum index</span></span><br><span class="line">	<span class="keyword">local</span> m = a[mi] <span class="comment">-- maximum value</span></span><br><span class="line">	<span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">			mi = i</span><br><span class="line">			m = val</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))</span><br></pre></td></tr></table></figure>
<p>Lua 总是调整函数返回值的个数去适用调用环境，当作为一个语句调用函数时，所<br>有返回值被忽略。假设有如下三个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">function <span class="title">foo0</span> <span class="params">()</span> end -- returns no results</span><br><span class="line">function <span class="title">foo1</span> <span class="params">()</span> return 'a' end -- returns 1 result</span><br><span class="line">function <span class="title">foo2</span> <span class="params">()</span> return 'a','b' end -- returns 2 results</span></span><br></pre></td></tr></table></figure>
<p>第一，当作为表达式调用函数时，有以下几种情况：</p>
<ol>
<li>当调用作为表达式最后一个参数或者仅有一个参数时，根据变量个数函数尽可能<br>多地返回多个值，不足补 nil，超出舍去。</li>
<li>其他情况下，函数调用仅返回第一个值（如果没有返回值为 nil）</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x,y = foo2() <span class="comment">-- x='a', y='b'</span></span><br><span class="line">x = foo2() <span class="comment">-- x='a', 'b' is discarded</span></span><br><span class="line">x,y,z = <span class="number">10</span>,foo2() <span class="comment">-- x=10, y='a', z='b'</span></span><br><span class="line">x,y = foo0() <span class="comment">-- x=nil, y=nil</span></span><br><span class="line">x,y = foo1() <span class="comment">-- x='a', y=nil</span></span><br><span class="line">x,y,z = foo2() <span class="comment">-- x='a', y='b', z=nil</span></span><br></pre></td></tr></table></figure>
<blockquote>
<font color="red">如果想要多个结果中的某一个可以用 ‘_’ 做占位符。</font>

</blockquote>
<h2 id="函数可以当作变量使用">函数可以当作变量使用</h2><p>lua中的函数是真的可以作为变量使用，这真是太酸爽了。你在程序里看呀定义一个字符串然后加个（）就变成了函数。顺便说下lua中的字符串连接是function_name ..() 是不是感觉威力强大。我是被这种动态类型的语言深深的迷住了。目前我看到了lua中的迭代器。后面的面向对象部分还没看，争取早点看完吧，让我好赶快学习怎么用这把枪。<br>还有就是lua的闭包。下面是闭包的感念。。。</p>
<hr>
<p><em>闭包是一个内部函数，它可以访问一个或者多个外部函数的外部局部变量。每次闭包的成功调用后这些外部局部变量都保存他们的值（状态）。当然如果要创建一个闭包必须要创建其外部局部变量。所以一个典型的闭包的结构包含两个函数：一个是闭包自己；另一个是工厂（创建闭包的函数）。</em></p>
<p>不过我现在还没理解闭包真正的好处。不过我今天理解了尾递归是可以优化的，其实就类似于goto不用保存调用函数的栈信息。这样就不容易栈爆掉了，现在的编译器已经做到了尾递归优化。</p>
<p>尾调用是一种类似在函数结尾的 goto 调用，当函数最后一个动作是调用另外一个函数时，我们称这种调用尾调用。</p>
<p>就我知道的尾递归优化最简单的就是阶乘。</p>
<p>第一个函数因为返回结果中有*法并不是尾递归。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> fact</span><br><span class="line">fact = <span class="function"><span class="keyword">function</span><span class="params">(n)</span></span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	 	<span class="keyword">return</span> n*fact(n-<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ans = fact(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>下面这个才是尾递归</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fact</span><br><span class="line">fact = <span class="function"><span class="keyword">function</span><span class="params">(n, value)</span></span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span> </span><br><span class="line">		<span class="keyword">return</span> value</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	 	<span class="keyword">return</span> fact(n-<span class="number">1</span>, value*n)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ans = fact(<span class="number">10</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>闭包的特性</p>
<p>就是内部函数用外部函数的局部变量时，此局部变量在子函数中是活跃的。返回下一个位置的元素。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list_iter</span> <span class="params">(t)</span></span></span><br><span class="line">	<span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">local</span> n = <span class="built_in">table</span>.getn(t)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> i &lt;= n <span class="keyword">then</span> <span class="keyword">return</span> t[i] <span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">iter = list_iter(t) 		<span class="comment">-- creates the iterator</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> element = iter() 		<span class="comment">-- calls the iterator</span></span><br><span class="line"><span class="keyword">if</span> element == <span class="keyword">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">	<span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们设计的这个迭代器也很容易用于范性 for 语句.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">t = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> list_iter(t) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Lua_面向对象">Lua 面向对象</h2><p>Lua 中一切复杂的数据结构都是有表构成的。应为在动态类型的语言中，没有类和对象的概念，不过这类语言有原型prototype。当调用不属于这些对象的操作时，会最先到prototype中查找这些操作。类与prototype的工作机制相同。不过本身prototype就可以理解为一个对象。</p>
<p>在 Lua 中，使用前面章节我们介绍过的继承的思想，很容易实现 prototypes.更明确的来说，如果我们有两个对象 a 和 b，我们想让 b 作为 a 的 prototype 只需要</p>
<blockquote>
<p>setmetatable(a, {__index = b})</p>
</blockquote>
<p>这样，对象 a 调用任何不存在的成员都会到对象 b 中查找。术语上，可以将 b 看作类，a 看作对象。</p>
<p>看下面的例子</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Account = &#123;</span><br><span class="line">	balance = <span class="number">0</span>,</span><br><span class="line">	withdraw = <span class="function"><span class="keyword">function</span><span class="params">(self, v)</span></span></span><br><span class="line">		self.balance = self.balance -v</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:deposit</span><span class="params">(v)</span></span></span><br><span class="line">	self.balance = self.balance + v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:new</span><span class="params">(O)</span></span></span><br><span class="line">	O = O <span class="keyword">or</span> &#123;&#125; <span class="comment">--如果没有提供参数就默认创建一个空表</span></span><br><span class="line">	<span class="built_in">setmetatable</span>(O, self)</span><br><span class="line">	self.__index = self  <span class="comment">--指定Account 的prototype是其自身</span></span><br><span class="line">	<span class="keyword">return</span> O</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = Account.new&#123;balance = <span class="number">0</span>&#125;</span><br><span class="line">a:deposit(<span class="number">100.00</span>)</span><br></pre></td></tr></table></figure>
<p>当我们调用 a:deposit(100.00)，我们实际上调用的是<br>a.deposit(a,100.00)（冒号仅仅是语法上的便利）。然而，Lua 在表 a 中找不到 deposit，因<br>此他回到 metatable 的__index 对应的表中查找，情况大致如下</p>
<blockquote>
<p>getmetatable(a).__index.deposit(a, 100.00)</p>
</blockquote>
<p>a的 metatable是 Account， Account.index也是 Account （因为 new函数中 self.index = self）。</p>
<p>继承机制不仅对方法有效，对表中所有的域都有效。所以，一个类不仅提供方法，也提供了他的实例的成员的默认值。</p>
<p>关于继承中方法的重载机制也就是利用符号表的查找替换机制。重定义子类中的方法就好。</p>
<h2 id="后记">后记</h2><p>继续一边看一边学吧。看到一个很有意思的关于lua的特性。先记录在这里。</p>
<ul>
<li><a href="http://blog.csdn.net/xocoder/article/details/9028347" target="_blank" rel="external">Lua查找表元素过程（元表、__index方法是如何工作的）</a></li>
<li><a href="http://www.lua.org/manual/5.3/" target="_blank" rel="external">Lua 的官方文档</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为什么学_Lua">为什么学 Lua</h2><p>其实我是不想学习的，应为对脚本语言这么“开放”的语法一直感觉很不规范。但是由于工作需要，不得不开始学习lua。我想说第一眼看上去lua和python的数据类型和语法规则简直真相（因为我刚看了一点python）。好了，至于lua有什么用？一般看网上说是为了支持游戏脚本。lua怎么说？应该是一个胶水吧？把各种语言穿起来。lua完全符合ANSI 的C语言规范。也就是可以直接用c编译器编译了。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[libevent 学习]]></title>
    <link href="http://ylwhere.tk/2015/09/08/libevent-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://ylwhere.tk/2015/09/08/libevent-学习/</id>
    <published>2015-09-08T11:38:43.000Z</published>
    <updated>2015-09-08T12:03:23.196Z</updated>
    <content type="html"><![CDATA[<h2 id="libevent_简介">libevent 简介</h2><p>libevent是一个基于事件触发的网络库，memcached底层也是使用libevent库。<br>libevent 是用C写的一个基于事件驱动的消息处理模型（编不下去了）。<br>总体来说，libevent有下面一些特点和优势：</p>
<ul>
<li>事件驱动，高性能；</li>
<li>轻量级，专注于网络；</li>
<li>跨平台，支持 Windows、Linux、Mac Os等；</li>
<li>支持多种 I/O多路复用技术， epoll、poll、dev/poll、select 和kqueue 等；</li>
<li>支持 I/O，定时器和信号等事件；</li>
</ul>
<hr>
<a id="more"></a>
<p>libevent有下面几大部分组成：</p>
<ul>
<li>事件管理包括各种IO（socket）、定时器、信号等事件，也是libevent应用最广的模块；</li>
<li>缓存管理是指evbuffer功能；</li>
<li>DNS是libevent提供的一个异步DNS查询功能；</li>
<li>HTTP是libevent的一个轻量级http实现，包括服务器和客户端</li>
</ul>
<h2 id="定时器代码">定时器代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt; </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt; </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// libevent头文件 </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;event.h&gt; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line">   </span><br><span class="line"><span class="comment">// 定时事件回调函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTime</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span> </span><br><span class="line"></span>&#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Game Over!"</span> &lt;&lt; endl; </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">struct</span> timeval tv; </span><br><span class="line">    tv.tv_sec = <span class="number">1</span>; </span><br><span class="line">    tv.tv_usec = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 重新添加定时事件（定时事件触发后默认自动删除） </span></span><br><span class="line">    event_add((<span class="keyword">struct</span> event*)arg, &amp;tv); </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123; </span><br><span class="line">    <span class="comment">// 初始化 </span></span><br><span class="line">    event_init(); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">struct</span> event evTime; </span><br><span class="line">    <span class="comment">// 设置定时事件 </span></span><br><span class="line">    evtimer_set(&amp;evTime, onTime, &amp;evTime); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">struct</span> timeval tv; </span><br><span class="line">    tv.tv_sec = <span class="number">1</span>; </span><br><span class="line">    tv.tv_usec = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 添加定时事件 </span></span><br><span class="line">    event_add(&amp;evTime, &amp;tv); </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 事件循环 </span></span><br><span class="line">    event_dispatch(); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我下载了libevent 的源代码，当然，首先先看看事件是如何定义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> event &#123;</span><br><span class="line">	TAILQ_ENTRY (event) ev_next;</span><br><span class="line">	TAILQ_ENTRY (event) ev_active_next;</span><br><span class="line">	TAILQ_ENTRY (event) ev_signal_next;</span><br><span class="line">	RB_ENTRY (event) <span class="keyword">ev_t</span>imeout_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> event_base *ev_base;</span><br><span class="line">	<span class="keyword">int</span> ev_fd;</span><br><span class="line">	<span class="keyword">short</span> ev_events;</span><br><span class="line">	<span class="keyword">short</span> ev_ncalls;</span><br><span class="line">	<span class="keyword">short</span> *ev_pncalls;	<span class="comment">/* Allows deletes in callback */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> timeval <span class="keyword">ev_t</span>imeout;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ev_pri;		<span class="comment">/* smaller numbers are higher priority */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*ev_callback)(<span class="keyword">int</span>, <span class="keyword">short</span>, <span class="keyword">void</span> *arg);  <span class="comment">//回调函数</span></span><br><span class="line">	<span class="keyword">void</span> *ev_arg;   <span class="comment">//回调函数的参数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ev_res;		<span class="comment">/* result passed to event callback */</span></span><br><span class="line">	<span class="keyword">int</span> ev_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 <code>TAILQ_ENTRY</code> 是定义好的宏。代表的是双向链表。而<code>RB_ENTRY</code>定义的是红黑树。</p>
<pre><code class="c">
<span class="preprocessor">#<span class="keyword">define</span> TAILQ_ENTRY(type)                        \
struct {                                \
    struct type *tqe_next;    /* next element */            \
    struct type **tqe_prev;    /* address of previous next element */    \
}</span>
<span class="preprocessor">#<span class="keyword">endif</span> /* !TAILQ_ENTRY */</span>
<span class="preprocessor">#ifndef RB_ENTRY</span>
<span class="preprocessor">#<span class="keyword">define</span> _EVENT_DEFINED_RBENTRY</span>
<span class="preprocessor">#<span class="keyword">define</span> RB_ENTRY(type)                            \
struct {                                \
    struct type *rbe_left;        /* left element */        \
    struct type *rbe_right;        /* right element */        \
    struct type *rbe_parent;    /* parent element */        \
    int rbe_color;            /* node color */        \
}</span>
</code></pre>
<h2 id="libevent_事件执行过程">libevent 事件执行过程</h2><p><img src="/img/blog/libevent_handler.png" alt=""></p>
<h2 id="调试_libevent">调试 libevent</h2><p>关于调试目前我没有好的办法。原谅我是如此的基础薄弱。我想到的办法是把libevent编译为.o 文件然后再进行调试。等有时间在看看吧。好像.debug目录下记录了关于源代码的信息。</p>
<p><img src="/img/blog/libevent_debug.png" alt=""></p>
<p>下面是可以调试的信息。记录了.o 文件对应的源代码的位置。目前我只能用这用办法了。</p>
<p><img src="/img/blog/libevent_debug_info.png" alt=""></p>
<p>有空再细细的探究吧，干活干活去了。。最近项目崔的好紧。。。</p>
<h2 id="参考">参考</h2><ul>
<li>libevent简介和使用</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="libevent_简介">libevent 简介</h2><p>libevent是一个基于事件触发的网络库，memcached底层也是使用libevent库。<br>libevent 是用C写的一个基于事件驱动的消息处理模型（编不下去了）。<br>总体来说，libevent有下面一些特点和优势：</p>
<ul>
<li>事件驱动，高性能；</li>
<li>轻量级，专注于网络；</li>
<li>跨平台，支持 Windows、Linux、Mac Os等；</li>
<li>支持多种 I/O多路复用技术， epoll、poll、dev/poll、select 和kqueue 等；</li>
<li>支持 I/O，定时器和信号等事件；</li>
</ul>
<hr>]]>
    
    </summary>
    
      <category term="libevent" scheme="http://ylwhere.tk/tags/libevent/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[突然就学起了andriod]]></title>
    <link href="http://ylwhere.tk/2015/09/08/%E7%AA%81%E7%84%B6%E5%B0%B1%E5%AD%A6%E8%B5%B7%E4%BA%86andriod/"/>
    <id>http://ylwhere.tk/2015/09/08/突然就学起了andriod/</id>
    <published>2015-09-08T11:18:12.000Z</published>
    <updated>2015-09-08T12:02:07.741Z</updated>
    <content type="html"><![CDATA[<h2 id="急冲冲的实习">急冲冲的实习</h2><p>本来是打算出去实习的，也确实现在在公司了。一句话，真是急冲冲，面试到入职就两天搞定了，一天面试，第二天打电话说通过了面试，第三天我就来了。面试先是笔试，当然是很基础的C/C++知识。并没有涉及太多的算法或者很深很广的东西，数据结构啦，或者操作系统，网络等等都没有。就是基础的C语言题目。不过还是有几道选择题不确定，而且笔试的话，每一次都在提醒我把字写得更好看点把，真是字如其人。这点倒是在我身上验证了。</p>
<a id="more"></a>
<p>来公司以后，我本来以为会让我先自我学习，没想到立马就开始干活了。每一个实习生都会给配一个师兄吧。叫师兄是应为他们看起来也就大两三岁的样子。带我的师兄，小宝宝马上就出生了。咩哈哈，要当爸爸的节奏啊。应该很激动有木有，不过公司好像年假和产假一起请也没有几天。哎，这就是不仁慈的地方，别人家的it公司不说朝九晚五，最起码也不会这样吧。目前公司是早上8:30上班。下午5:30下班。有的部门还要加班，一三五六加班，晚上到8:30。我真的想呵呵（因为和实习工资比起来）。。。。</p>
<h2 id="突然就学习了android">突然就学习了android</h2><p>本来我一向是自诩学C/C++的人。心里鄙视学java的。好吧，其实是我内心害怕学java。但是看了三天代码和android书。感觉android设计的编程框架如此的美。真是太方便使用了。UI 和数据显示分开，数据显示和业务逻辑也可以分开。总之，真心棒。</p>
<p>推荐一本书就是：&gt; 开始启程，你的第一行Android 代码</p>
<p>还有就是突然转到android new一个类的时候总感觉怪怪的。不过也只是语法不同。底层还是指针在玩。<br>放一张图吧，介绍的是View 类的继承关系。</p>
<p><img src="/img/blog/View.png" alt=""></p>
<p>还有一点就是android的界面就是编写xml文件，用起来好放心，属性一大堆，当然也不用记，用的时候查文档就好。java 中支持匿名类，就如C++的lambda表达式一样，第一眼看上起我竟然发现也不是不可以接受。<br>举个例子也算是记忆吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.view.Window;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> android.widget.ProgressBar;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Button button;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        getWindow().requestFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.search_result);</span><br><span class="line">        </span><br><span class="line">        button = (ButtonView) findViewById(R.id.button);</span><br><span class="line">		<span class="comment">//button new了一个匿名监听类对象</span></span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">				</span><br><span class="line">				EditText editText = (EditText) findViewById(R.id.edit_text);</span><br><span class="line">				</span><br><span class="line">				String textContent = editText.getText().toString();</span><br><span class="line">				</span><br><span class="line">				ImageView imageView = (ImageView) findViewById(R.id.image_view);</span><br><span class="line">				ProgressBar progress_bar = (ProgressBar) findViewById(R.id.progress_bar);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">int</span> progress = progress_bar.getProgress();</span><br><span class="line">				</span><br><span class="line">				progress += <span class="number">10</span>;</span><br><span class="line">				</span><br><span class="line">				progress_bar.setProgress(progress);</span><br><span class="line">				</span><br><span class="line">			<span class="comment">//	imageView.setImageResource(R.drawable.img1);</span></span><br><span class="line">			<span class="comment">//	Toast.makeText(FirstActivity.this, textContent,</span></span><br><span class="line">			<span class="comment">//			Toast.LENGTH_SHORT).show();</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>继续学看书了，每天对着手机调试程序，每天对着手机说话。。。呵呵哒。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="急冲冲的实习">急冲冲的实习</h2><p>本来是打算出去实习的，也确实现在在公司了。一句话，真是急冲冲，面试到入职就两天搞定了，一天面试，第二天打电话说通过了面试，第三天我就来了。面试先是笔试，当然是很基础的C/C++知识。并没有涉及太多的算法或者很深很广的东西，数据结构啦，或者操作系统，网络等等都没有。就是基础的C语言题目。不过还是有几道选择题不确定，而且笔试的话，每一次都在提醒我把字写得更好看点把，真是字如其人。这点倒是在我身上验证了。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://ylwhere.tk/tags/android/"/>
    
      <category term="java" scheme="http://ylwhere.tk/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[暑期状态]]></title>
    <link href="http://ylwhere.tk/2015/07/30/%E6%9A%91%E6%9C%9F%E7%8A%B6%E6%80%81/"/>
    <id>http://ylwhere.tk/2015/07/30/暑期状态/</id>
    <published>2015-07-30T09:58:07.000Z</published>
    <updated>2015-07-30T10:30:45.691Z</updated>
    <content type="html"><![CDATA[<h2 id="目前的心情">目前的心情</h2><p>我是6月18号从考试完回家，在家待了大概2周。也就是7月1号再从家里回到学校。回到学校到现在又大概一个月过去了。我着急啊，怎么能不着急呢。着急的原因是我感觉自己会的东西太少了，怕毕业以后找不到好的工作。怕自己会变得越来越懒，越来越堕落。<br><a id="more"></a><br>回到学校后，我开始变得很懒。因为内心不愿意去所里从事老板的工作。我觉得所里对我的帮助并不多，而且会比较浪费时间。一去就是一天没有了，还要忍受附近那嘈杂的环境噪声，和看不懂的万行代码。师兄说，看这些代码没有意义。我也觉得是这样的。就如冰山一样，你花费了巨大的精力看到了一角可是收获的并不多。所里我想逃避，我抱怨。为什么我会跟一个这样的导师。从我研究生开始，都没见过20次的老师。我不知道他在干吗，或许他真的很忙吧。忙的都忘了他手下的研究生。忙着为自己规划着家庭和未来。看着隔壁实验室老板每周都开会，或者老板的教导。心里除了羡慕就剩下憎恨了。我要早点离开这个地方。是的，我讨厌这里。</p>
<h2 id="在学校这几周的日子">在学校这几周的日子</h2><p>从家里回来我就开始一边玩一边想找找实习，当然，我玩的很high。整天整天的看电视，看电影。出去玩，但是心里也有内疚，但是我就是不愿意去改变。也在等待着机会。也算是第一次比较正式的面试吧。大概都是先通过电话面试，然后再去二面或者三面。很幸运的是上周我去了上海面试。一家做大数据的公司，面试聊的比较好。感觉两个面试官都是师兄对师弟一样，非常nice。当然，面试很顺利通过了。最后和hr谈。她说：你能有时间出去实习么?你导师让你出去么？我知道我没法答复他。因为我给老板发过邮件，老板不同意我出去。后来我又给他打电话。他还是不同意我出去。我能怎么办？难不成成的冒着现在和他撕破关系的风险。我当时真想说：老师，您真会玩。挂了电话。心里暗骂。然后就是一顿难受。</p>
<h2 id="研二估计就是熬时间了">研二估计就是熬时间了</h2><p>没办法，只有放弃这个机会，但是我也不能再玩的那么疯狂了。就算他不让我出去实习，我也得想办法好好度过这一年。毕竟，时间过的很快的。我一边看书，一边跟本地的it企业发简历，希望能在这里找个实习。所里面还好有一个师兄人比较好，也算是给我去所里留下最后一点欣慰吧。好羡慕那些可以出去实习的同学，希望你们珍惜机会吧。同时我也祝福你们，哈哈。</p>
<p>刚投了一份简历，不知道对面有没有看到，希望可以早点回复我。也希望我有面试的机会并能顺利通过。这几天突然对编译器很感兴趣，哈哈。觉得好神奇。继续看代码吧，先码字到这里。</p>
<blockquote>
<ul>
<li>一切仍在继续……</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="目前的心情">目前的心情</h2><p>我是6月18号从考试完回家，在家待了大概2周。也就是7月1号再从家里回到学校。回到学校到现在又大概一个月过去了。我着急啊，怎么能不着急呢。着急的原因是我感觉自己会的东西太少了，怕毕业以后找不到好的工作。怕自己会变得越来越懒，越来越堕落。<br>]]>
    
    </summary>
    
      <category term="心路札记" scheme="http://ylwhere.tk/categories/%E5%BF%83%E8%B7%AF%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python 入门学习]]></title>
    <link href="http://ylwhere.tk/2015/07/06/python-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://ylwhere.tk/2015/07/06/python-入门学习/</id>
    <published>2015-07-06T03:07:29.000Z</published>
    <updated>2015-07-06T05:41:55.919Z</updated>
    <content type="html"><![CDATA[<h2 id="python_介绍">python 介绍</h2><p>Python是一种计算机程序设计语言。你可能已经听说过很多种流行的编程语言，比如非常难学的C语言，非常流行的Java语言，适合初学者的Basic语言，适合网页编程的JavaScript语言等等。</p>
<p>Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。</p>
<a id="more"></a>
<p>我学习python是感觉他对自动化测试会有很大的用处，目前也只是跟着教程学习，并没有什么深入的理解，不过感觉python中的元组对于索引和引用真心好用。绝对是高级的抽象语言，list。</p>
<p>看到了python中可以提供函数式编程。对此我就又仅仅是C语言的一点知识，传递函数指针可以实现函数间的调用，但是函数参数和个数并不做检查。</p>
<p><em>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</em></p>
<p>我一直是看着这个链接的教程：<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001418612030427b1f1cf4ea04c41368e8a6753dca43070000" target="_blank" rel="external">python 教程</a> 里面提到一个练习题。用filter来实现1~100之内的素数过滤。</p>
<p>程序代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">elif</span>(n==<span class="number">2</span>):</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	<span class="keyword">elif</span>(n==<span class="number">3</span>):</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		sqrt_n = math.sqrt(n)</span><br><span class="line">		step = <span class="number">2</span></span><br><span class="line">		<span class="keyword">while</span> step &lt;= sqrt_n:</span><br><span class="line">			<span class="keyword">if</span> n % step == <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				step = step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">x = filter(is_prime, range(<span class="number">1</span>,<span class="number">100</span>))</span><br><span class="line"><span class="keyword">print</span> x</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<pre><code>[wyl<span class="variable">@localhost</span> <span class="constant">Code]</span><span class="variable">$ </span>python prime.py 
[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>]
</code></pre><p>总结：python 感觉很好用，因为是解释性语言，虽然效率没有编译型语言高，但是实际使用过程中并没有感觉到很慢。</p>
<p>附：学习参考的网站：<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="external">Python 2.7教程</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="python_介绍">python 介绍</h2><p>Python是一种计算机程序设计语言。你可能已经听说过很多种流行的编程语言，比如非常难学的C语言，非常流行的Java语言，适合初学者的Basic语言，适合网页编程的JavaScript语言等等。</p>
<p>Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。</p>]]>
    
    </summary>
    
      <category term="python" scheme="http://ylwhere.tk/tags/python/"/>
    
      <category term="python" scheme="http://ylwhere.tk/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一次电话面试]]></title>
    <link href="http://ylwhere.tk/2015/06/17/%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95/"/>
    <id>http://ylwhere.tk/2015/06/17/电话面试/</id>
    <published>2015-06-17T06:16:41.000Z</published>
    <updated>2015-06-17T07:31:11.979Z</updated>
    <content type="html"><![CDATA[<h2 id="电话面试">电话面试</h2><p>记录已下自己第一次的电话面试，感觉答的好失败。其实不是自己紧张，是感觉确实答的不太好。果然电话面试时基础问题，确实没有涉及比较深入的内容。问了一些数据库和mysql的问题，还有javascript的问题。面试官应该是个学长吧，声音听起来很慈祥，人应该非常nice。</p>
<a id="more"></a>
<h2 id="面试的问题">面试的问题</h2><p>本来说好的一个小时的面试，结果我感觉是学长感觉我答的不太好，也没有跟我说太久，20分钟左右的时间就结束了。</p>
<p>关于sql的问题大概是：有A、B两个表，假如A中有（key, name, sex） B中有（key,name, score） 查询语句：怎样输出A,B中都有的属性。我并不知道这个问题该如何回答，结果就说：<code>create 视图 form select * from A,B where A.key = B.key</code> 然后再从中删选重复的属性元组。</p>
<p>答案：<font color="red">先空缺吧。</font></p>
<p>其他问题就不说了，否则对面试官和面试者都不太公平，总之，我本来以为会问我底层的东西，其实我也没有表达出来我底层懂得比较多，就是面试官问什么，我答什么，没有把自己想要表达的东西说出来。</p>
<blockquote>
<p>电话面试还是要想办法说出来自己比较理解的方向，要不别人根本不了解你。</p>
</blockquote>
<p>还是觉得自己好浮躁，很多东西没有直达的很清楚，或者说是其实自己还是太懒，明明有些问题非常常用自己也知道不懂，但是还是不愿意学习。另外一个就是项目经验还是太少。还是要多动手。</p>
<p>时间过的真的好快，不知不觉一学期又过去了。继续前进吧，总结失败，废话也不多说了。</p>
<p>加油！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="电话面试">电话面试</h2><p>记录已下自己第一次的电话面试，感觉答的好失败。其实不是自己紧张，是感觉确实答的不太好。果然电话面试时基础问题，确实没有涉及比较深入的内容。问了一些数据库和mysql的问题，还有javascript的问题。面试官应该是个学长吧，声音听起来很慈祥，人应该非常nice。</p>]]>
    
    </summary>
    
      <category term="intern" scheme="http://ylwhere.tk/tags/intern/"/>
    
      <category term="interview" scheme="http://ylwhere.tk/categories/interview/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 资料整理]]></title>
    <link href="http://ylwhere.tk/2015/06/04/Git-%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    <id>http://ylwhere.tk/2015/06/04/Git-资料整理/</id>
    <published>2015-06-04T08:38:07.000Z</published>
    <updated>2015-06-04T12:34:55.393Z</updated>
    <content type="html"><![CDATA[<h2 id="一、Git_是什么">一、Git 是什么</h2><p>一直在用git 和github，可是除了基本的git init 命令，对其他的git的分支啊，远端啊，恢复啊完全没有了解，所以想趁这个时间看不进书，整理一下git的资料。让自己有一个系统的了解，以后查询使用也会更加的方便。资料基本上都是参考文件的整理，为的就是自己对git有个整体的了解，仅供自己学习而用。</p>
<a id="more"></a>
<p>非常简单地说，Git 是一个快速、可扩展的分布式版本控制系统，它具有极为丰<br>富的命令集，对内部系统提供了高级操作和完全访问。所谓版本控制系统 (Version<br>Control System)，从狭义上来说，它是软件项目开发过程中用于储存我们所写的代<br>码所有修订版本的软件，但事实上我们可以将任何对项目有帮助的文档交付版本控<br>制系统进行管理。</p>
<p>为什么使用版本控制系统</p>
<blockquote>
<font color="red">版本控制系统是为懒人准备的，它让懒人们比那些善于备份文档的勤劳人拥有<br>更干净的文件系统以及更多的可以活着的时间。</font>

</blockquote>
<h2 id="二、Git_安装和入门">二、Git 安装和入门</h2><p>1.Centos 上的安装为：</p>
<pre><code>sudo yum <span class="keyword">install</span> git
</code></pre><p>完成安装后还要进行初始化的配置<br>Git初始化配置<br>1） 配置使用git仓库的人员姓名</p>
<pre><code>git config --global user<span class="class">.name</span> <span class="string">"Your Name Comes Here"</span>   
</code></pre><p>2） 配置使用git仓库的人员email </p>
<pre><code>git config --global user<span class="class">.email</span> you@yourdomain<span class="class">.example</span><span class="class">.com</span>
</code></pre><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。       </p>
<p>2.创建新仓库<br>创建新文件夹，打开，然后执行 </p>
<pre><code><span class="title">git</span> init
</code></pre><p>以创建新的 git 仓库。<br>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>3.向仓库中添加文件</p>
<p>由于 Git 在向仓库中添加文档时并非是简单地文档复制过去，势必要将所添加文档进行一番处理，生成 Git 仓库所能接受的数据格式，Git 称这个过程为 “take a snapshot”（生成快照）。文件会加入到index目录，但此时还并未真正的添加到仓库中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add&lt;filename&gt;</span><br><span class="line">或者 </span><br><span class="line">git add *</span><br></pre></td></tr></table></figure>
<p>4.想仓库提交文件</p>
<p>使用如下命令以实际提交改动：</p>
<pre><code><span class="title">git</span> commit -m <span class="string">"代码提交信息"</span>  
</code></pre><p><code>-m</code> 后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<h3 id="Git_概念">Git 概念</h3><p>Git库中由三部分组成</p>
<p>的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。</p>
<p>1） 工作目录：用户本地的目录；</p>
<p>2） Index（索引）：将工作目录下所有文件（包含子目录）生成快照，存放到一个临时的存储区域，Git 称该区域为索引。</p>
<p>3） 仓库：将索引通过commit命令提交至仓库中，每一次提交都意味着版本在进行一次更新。<br>整个过程如下图所示：</p>
<p><img src="/img/blog/git_flow.png" alt=""></p>
<h3 id="Git_远程推送">Git 远程推送</h3><p><code>git commit</code> 后文件只是同步到了本地的仓库的HEAD中了。执行如下命令将这些改动提交到远端仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>可以把master 换成任何分支。如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &#60;server&#62;</span><br></pre></td></tr></table></figure>
<h3 id="分支">分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p>关于分支的相机介绍可以看下面的链接：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="external">Git 分支</a></p>
<p><img src="/img/blog/git_branch.png" alt=""></p>
<p>创建一个叫做“feature_x”的分支，并切换过去：  </p>
<pre><code>git checkout -<span class="tag">b</span> feature_x
</code></pre><p>切换回主分支：  </p>
<pre><code>git checkout master<span class="escape">` </span> 
</code></pre><p>再把新建的分支删掉：  </p>
<pre><code><span class="label">git</span> <span class="keyword">branch </span>-d feature_x
</code></pre><p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：  </p>
<p>git push origin <branch></branch></p>
<h3 id="更新与合并">更新与合并</h3><p>要更新你的本地仓库至最新改动，执行：  </p>
<pre><code><span class="title">git</span> pull
</code></pre><p>以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：  </p>
<pre><code>git merge <span class="tag">&lt;<span class="title">branch</span>&gt;</span>
</code></pre><p>在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：   </p>
<pre><code><span class="label">git</span> <span class="keyword">add </span>&lt;filename&gt;
</code></pre><p>在合并改动之前，你可以使用如下命令预览差异：  </p>
<pre><code>git diff <span class="tag">&lt;<span class="title">source_branch</span>&gt;</span> <span class="tag">&lt;<span class="title">target_branch</span>&gt;</span>
</code></pre><h2 id="三、Git_命令介绍">三、Git 命令介绍</h2><p>1&gt; Git文档忽略机制 </p>
<p>工作目录中有一些文件是不希望接受Git 管理的，譬如程序编译时生成的中间文件等等。Git 提供了文档忽略机制，可以将工作目录中不希望接受Git 管理的文档信息写到同一目录下的.gitignore 文件中。<br>如下图所示，忽略所有后缀.xlxs文件。</p>
<p><img src="/img/blog/git_ignore.png" alt=""></p>
<p>2&gt; Git help<br>       Git help 获取git基本命令<br>（如果要知道某个特定命令的使用方法，例如：使用Git help clone，来获取git clone的使用方法）。</p>
<p>3&gt; Git init </p>
<p>创建一个空的Git库。在当前目录中产生一个.git 的子目录。在.git目录下有一个config文件，可以修改其中的配置信息。</p>
<p>4&gt; Git add </p>
<p>将当前工作目录中更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步。 </p>
<p>5&gt; Git commit </p>
<p>提交当前工作目录的修改内容。 直接调用git commit命令，会提示填写注释。通过如下方式在命令行就填写提交注释：git commit -m “Initial commit of gittutor reposistory”。<br>git commit还有一个 -a的参数，可以将那些没有通过git add标识的变化一并强行提交，但是不建议使用这种方式。 </p>
<p>6&gt; Git status </p>
<p>查看版本库的状态。可以得知哪些文件发生了变化，哪些文件还没有添加到git库中等等。 建议每次commit前都要通过该命令确认库状态。 如果调用了git status命令，一定要格外注意那些提示为 “Changed but not updated:”的文件。 这些文件都是与上次commit相比发生了变化，但是却没有通过git add标识的文件。 </p>
<p>7&gt; Git log </p>
<p>查看历史日志，包含每次的版本变化。每次版本变化对应一个commit id.<br>在项目日志信息中，每条日志的首行（就是那一串字符）为版本更新提交所进行的命名，我们可以将该命名理解为项目版本号。项目版本号应该是唯一的，默认由 Git 自动生成，用以标示项目的某一次更新。如果我们将项目版本号用作git-show 命令的参数，即可查看该次项目版本的更新细节。</p>
<p><img src="/img/blog/git_log.png" alt=""></p>
<p>8&gt; Git merge </p>
<p>把服务器上下载下来的代码和本地代码合并。或者进行分支合并。</p>
<p>9&gt; Git reset </p>
<p>库的逆转和恢复。</p>
<pre><code>git reset [--mixed | --soft | --hard] <span class="annotation">[&lt;commit-ish&gt;]</span>。
</code></pre><p>—mixed 是 git-reset 的默认选项，它的作用是重置索引内容，将其定位到指定的项目版本，而不改变你的工作树中的所有内容，只是提示你有哪些文件还未更新。  </p>
<p>—soft 选项既不触动索引的位置，也不改变工作树中的任何内容，但是会要求它们处于一个良好的次序之内。该选项会保留你在工作树中的所有更新并使之处于待提交状态。</p>
<p>—hard这个命令就会导致所有信息的回退， 包括文件内容。 一般只有在重置废弃代码时，才用它。 执行后，文件内容也无法恢复回来了。（回退了工作目录、index和仓库中的内容）。</p>
<p><img src="/img/blog/git_resert.png" alt=""></p>
<p>10&gt; Git diff </p>
<p>把本地的代码和index中的代码进行比较，或者是把index中的代码和本地仓库中的代码进行比较。<br>1） Git diff<br>比较工作目录和Index中的代码。<br>2） Git diff - - cached<br>比较index和本地仓库中的代码。   </p>
<p>11&gt; Git checkout </p>
<p>切换到分支</p>
<p>1) 创建一个新分支，并切换到该分支上   </p>
<pre><code>Git checkout –<span class="tag">b</span> 新分支名 
</code></pre><p>2）切换到某个已经建立的本地分支local_branch   </p>
<pre><code>Git checkout <span class="built_in">local</span>_branch   
</code></pre><p>（使用cat .git/HEAD后，显示refs:refs/heads/ local_branch）   </p>
<p>3）切换到某个分支：git checkout 分支名</p>
<pre><code>切换到主分支：git checkout master
</code></pre><p>4）删除分支</p>
<pre><code><span class="label">git</span> <span class="keyword">branch </span>–D 分支名
</code></pre><p>注意： 删除后，发生在该分支的所有变化都无法恢复。强制删除此分支。 </p>
<p>5）比较两个分支上的文件的区别</p>
<pre><code><span class="title">git</span> diff master 分支名 （比较主分支和另一个分支的区别）
</code></pre><p>6）查看分支历史</p>
<pre><code>git-<span class="literal">show</span>-branch （查看当前分支的提交注释及信息）

git-<span class="literal">show</span>-branch -<span class="literal">all</span>（查看所有分支的提交注释及信息）
</code></pre><p>7）合并分支</p>
<p>法一：</p>
<pre><code>git <span class="built_in">merge</span> “注释” 合并的目标分支 合并的来源分支
</code></pre><p>如果合并有冲突，git会有提示。</p>
<p>例如：</p>
<pre><code>git checkout master （切换到master分支）

git <span class="operator"><span class="keyword">merge</span> HEAD branch1 (合并<span class="keyword">master</span>分支和branch1分支)或者：git <span class="keyword">merge</span> <span class="keyword">master</span> branch1</span>
</code></pre><p>法二：</p>
<pre><code><span class="title">git</span> pull 合并的目标分支 合并的来源分支
</code></pre><p>例如: </p>
<pre><code>git checkout master （切换到master分支）

git pull . bra<span class="label">nch1</span>（合并当前分支和bra<span class="label">nch1</span>分支）
</code></pre><p>12&gt; Git config</p>
<p>利用这个命令可以新增、更改Git的各种设置，例如: </p>
<pre><code>git config branch<span class="class">.master</span><span class="class">.remote</span> origin
</code></pre><p>就将master的远程版本库设置为别名叫做origin版本库。</p>
<p>13&gt; Git tag</p>
<p>创建、列出、删除或者验证一个标签对象（使用GPG签名的）。</p>
<p>可以将某个具体的版本打上一个标签，这样就不需要记忆复杂的版本号哈希值字符串了，例如:</p>
<pre><code>git tag revert_version bbaf6fb<span class="number">5060b4875</span>b18ff9ff637ce<span class="number">118256d6f20</span>
</code></pre><p> 来标记这个被你还原的版本，那么以后你想查看该版本时，就可以使用 revert_version标签名，而不是哈希值了。</p>
<hr>
<p>14&gt; Git clone</p>
<p>取出服务器的仓库的代码到本地建立的目录中（与服务器交互）。</p>
<p>通过git clone获取远端git库后，.git/config中的开发者信息不会被一起clone过来。仍然需要为本地库的.git/config文件添加开发者信息。此外，开发者还需要自己添加 . gitignore文件。</p>
<p>15&gt;  Git pull</p>
<p>从服务器的仓库中获取代码，和本地代码合并。（与服务器交互，从服务器上下载最新代码，等同于： Git fetch + Git merge）<br>从其它的版本库（既可以是远程的也可以是本地的）将代码更新到本地，例如：</p>
<pre><code><span class="title">git</span> pull origin master 
</code></pre><p>就是将origin这个版本库的代码更新到本地的master主分支。</p>
<p>git pull可以从任意一个git库获取某个分支的内容。用法如下：</p>
<pre><code><span class="title">git</span> pull username<span class="variable">@ipaddr</span>:远端repository名远端分支名 本地分支名
</code></pre><p>这条命令将从远端git库的远端分支名获取到本地git库的一个本地分支中。其中，如果不写本地分支名，则默认pull到本地当前分支。</p>
<p>16&gt; Git push</p>
<p>将本地commit的代码更新到远程版本库中，例如 “git push origin”就会将本地的代码更新到名为orgin的远程版本库中。</p>
<p>git push和git pull正好想反，是将本地某个分支的内容提交到远端某个分支上。用法：</p>
<pre><code><span class="title">git</span> push username<span class="variable">@ipaddr</span>:远端repository名本地分支名 远端分支名
</code></pre><p>这条命令将本地git库的一个本地分支push到远端git库的远端分支名中。</p>
<p>17&gt; Git fetch</p>
<p>从服务器的仓库中下载代码。（与服务器交互，从服务器上下载最新代码）</p>
<p>相当于从远程获取最新版本到本地，不会自动merge，比Git pull更安全些。<br>使用此方法来获取服务器上的更新。</p>
<h2 id="四、参考">四、参考</h2><ul>
<li><a href="http://files.cnblogs.com/files/phphuaibei/git%E6%90%AD%E5%BB%BA.pdf" target="_blank" rel="external">Git 使用指南</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git 教程</a></li>
<li><a href="http://www.uml.org.cn/pzgl/201208073.asp" target="_blank" rel="external">Git 常用命令解说</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">Git 简明指南</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、Git_是什么">一、Git 是什么</h2><p>一直在用git 和github，可是除了基本的git init 命令，对其他的git的分支啊，远端啊，恢复啊完全没有了解，所以想趁这个时间看不进书，整理一下git的资料。让自己有一个系统的了解，以后查询使用也会更加的方便。资料基本上都是参考文件的整理，为的就是自己对git有个整体的了解，仅供自己学习而用。</p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://ylwhere.tk/tags/Git/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[makefile 入门学习]]></title>
    <link href="http://ylwhere.tk/2015/06/03/makefile-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://ylwhere.tk/2015/06/03/makefile-入门学习/</id>
    <published>2015-06-02T23:49:32.000Z</published>
    <updated>2015-06-03T05:26:15.445Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_make_的工作原理">1. make 的工作原理</h2><p>make 工具最基本的功能是调用makefile文件，通过makefile文件来描述程序编译的整个过程，不必每次输入gcc 或者 g++ 等命令来完成编译工作。<br>makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。<br><a id="more"></a></p>
<p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。 </p>
<hr>
<p>来看一个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add:main.o add.o</span><br><span class="line">	gcc -o add main.o add.o</span><br><span class="line">main.o : main.c</span><br><span class="line">	gcc -c main.c</span><br><span class="line">add.o : add.c</span><br><span class="line">	gcc -c add.c</span><br><span class="line">    </span><br><span class="line">clean: </span><br><span class="line">	rm main.o add.o add</span><br></pre></td></tr></table></figure></p>
<p>在当前目录下输入make命令，系统将自动完成如下操作：</p>
<ol>
<li>make 工具在当前目录下依次寻找GNUmakefile、makefile或者Makefile的文件，找到一个则停止查找；</li>
<li>如果找到，它会查找文件中的第一个目标，如上面例子的add，并将这个文件作为最后一步生成的目标。</li>
<li>如果add文件不存在或者add所依赖的后面的“.o”文件的修改时间比add文件晚，则系统执行后面所定义的命令来生成这个add文件；</li>
<li>如果add所依赖的“.o”文件也不存在，则make工具会在当前文件中查找目标为“.o”文件的依赖文件，如果找到就根据相应的规则生成“.o”文件；</li>
<li>如果makefile文件列出的源文件都存在，make工具就会先生成“.o”文件，然后再用“.o”文件链接成可执行文件，否则将提示“找不到目标”错误。</li>
</ol>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。<br>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。 </p>
<hr>
<h2 id="2-_make的语法及参数选项">2. make的语法及参数选项</h2><p>make 命令主要有标志、宏定义和目标名三个可选参数，其标准形式：</p>
<blockquote>
<p>make [标志][宏定义][目标名]</p>
</blockquote>
<p>主要的标志选项及其含义如下: 可以通过 make —help 查看</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">对应的英文单词</th>
<th style="text-align:left">功能和含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f FILE</td>
<td style="text-align:left">file</td>
<td style="text-align:left">读取FILE文件作为一个makefile</td>
</tr>
<tr>
<td>-i</td>
<td style="text-align:left">ignore-errors</td>
<td style="text-align:left">忽略命令执行返回的出错信息</td>
</tr>
<tr>
<td>-n</td>
<td style="text-align:left">just-print</td>
<td style="text-align:left">非执行模式，输出所有执行命令，但并不执行</td>
</tr>
<tr>
<td>-d</td>
<td style="text-align:left">debug</td>
<td style="text-align:left">Debug模式，输出有关文件和检测时间的详细信息</td>
</tr>
<tr>
<td>-I dir</td>
<td style="text-align:left">directory</td>
<td style="text-align:left">包含makefile文件时，利用该选项指定搜索目录</td>
</tr>
</tbody>
</table>
<p>执行make命令时，可以通过参数为makefile文件内的宏变量CC赋值，通过宏变量CC指定不同的编译器来编译源文件，如下图：</p>
<p><img src="/img/blog/make_ex1.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#this is a example </span></span><br><span class="line">CC=</span><br><span class="line"></span><br><span class="line">add:main.o add.o</span><br><span class="line">	$(CC) -o add main.o add.o</span><br><span class="line">main.o : main.c</span><br><span class="line">	$(CC) -c main.c</span><br><span class="line">add.o : add.c</span><br><span class="line">	$(CC) -c add.c</span><br><span class="line">    </span><br><span class="line">clean: </span><br><span class="line">	rm main.o add.o add</span><br></pre></td></tr></table></figure>
<p>目标名选项用来指定make命令要编译或者执行的目标，并且允许同时指定多个目标，如上例中的<code>make clean</code>。操作时按照从左到右的顺序依次编译或执行各个目标。如果不指定目标选项，则系统默认指向makefile文件中的第一个目标，如上例中的add。</p>
<h2 id="3-_makefile_文件">3. makefile 文件</h2><p>make 命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。makefile 文件遵循一定的格式，它通常包含以下内容：</p>
<ul>
<li>需要由make命令创建的目标对象(targets)，可以是Object File，也可以是执行文件，还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述；</li>
<li>要创建的目标对象所依赖的文件(dependent_files)；</li>
<li>创建每个目标对象时需要运行的命令(command)。</li>
</ul>
<blockquote>
<p>Makefile 的一般格式：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targets ... : dependent_files ...</span><br><span class="line">    (tab)command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="3-1_makefile_的包含">3.1 makefile 的包含</h3><p>与C/C++ 的 “#include” 一样，makefile 可以使用include关键字将其他makefile包含进来，被包含的内容会原封不动的加载到当前makefile文件的包含位置。include 关键字后面指定要包含的文件名、路径或者变量，它们之间用一个或者多个空格隔开。举例来说，倘若有几个makefile如a.make、b.make、c.make，还有一个makefile相关文件make.rules，以及一个变量include_dir,则下面的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include_dir := /usr/include</span><br><span class="line">include *.make $(include_dir)make.rules</span><br></pre></td></tr></table></figure>
<p>等价于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include a.make b.make c.make /usr/include_dir/make.rules</span><br></pre></td></tr></table></figure></p>
<p>makefile 命令执行时，先将include关键字后面指定的相关文件内容加载进来并安置在当前位置，如果文件是绝对路径，make 命令将在当前目录寻找，倘若未找到，make命令一般还会去下面几个目录中寻找：</p>
<ul>
<li>如果执行make命令时使用了“-I”参数指定了某个目录，make命令回去该目录中寻找相关文件；</li>
<li>如果 /usr/local/bin 或 /usr/include 目录存在，make命令将会去该目录下寻找相关文件。</li>
</ul>
<p>make 命令如果未找到include关键字指定的某个文件，将会报错并且停止运行，想让make命令不去理会这些相关文件是否存在而继续执行，可以在include前面加上一个减号“-”，它表示include加载过程中出现的错误都将被忽略。</p>
<h3 id="3-2_makefile_的语法规则">3.2 makefile 的语法规则</h3><p>一个基本的makefile主要是由目标对象、依赖文件、变量和命令4部分组成。一个makefile文件中可以有多个目标对象，要生成特定的目标对象，在执行make命令时跟上目标对象即可。如“make add.o”，倘若不指定，make命令自动将makefile文件中第一个目标对象作为默认对象来生成。</p>
<p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 </p>
<ol>
<li><p>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 </p>
</li>
<li><p>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。 </p>
</li>
<li><p>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 </p>
</li>
<li><p>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 </p>
</li>
<li><p>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。 </p>
</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。 </p>
<h3 id="3-3_makefile_与命令">3.3 makefile 与命令</h3><p>makefile 中的命令由一些Shell 命令行组成，这些命令被一条条地执行，除了第一条紧跟在依赖关之后的命令需要使用分号隔开以外，其他每一行，其他每一行命令行必须以制表符tab开始。多个命令行之间可以有空行或者注释行。</p>
<blockquote>
<p>命令的执行</p>
</blockquote>
<p>当makefile中的目标需要被重建时，此条目标对应的依赖关系后面紧跟的命令将会被执行，如果有多行命令，则makefile将会为每一行命令分配一个子shell去执行，因此多行命令之间的执行是相互独立的，也不存在依赖关系。<br><strong>需要注意的是，</strong> 在一条依赖关系下的多个命令行中，前一行中的cd命令改变目录后不会对后面的命令行产生影响，也就是说后续命令行的执行目录不会是之前使用cd命令进入的那个目录。而Makefile中处于同一行、用分号分割的多个命令属于同一个子shell，前面cd 命令的目录切换动作可以影响到分号后面的其他命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello:src/hello.o src/hello.h</span><br><span class="line">    cd src/; gcc hello.c -o hello</span><br></pre></td></tr></table></figure></p>
<p>如果需要将一个完整的Shell命令书写到多行上，可以使用反斜杠“\”来处理多行命令的连接，表示反斜杠前后的两行属于同一行命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello:src/hello.o src/hello.h</span><br><span class="line">    cd src/; \</span><br><span class="line">    gcc hello.c -o hello</span><br></pre></td></tr></table></figure></p>
<p><strong>并发执行命令</strong></p>
<p>make 可以同时执行多条命令，默认情况下，make在同一时刻汁执行一条命令，后一条命令依赖前一天命令的执行完成，为了同时执行多条命令，可以执行make命令时添加“-J”选项来指导同时执行命令条数的上线。<br>如果“-j”之后跟一个整数，其含义表示make在同一时刻允许执行的最多命令条数；如果选项“-j”之后不跟整数，则表示不限制同时执行的命令条数，即每条依赖关系后有多条命令就同时执行多少条。make -j 的并发执行时按依赖关系并发执行的。没有依赖关系的命令可以并发执行。</p>
<h3 id="3-4_makefile_与变量">3.4 makefile 与变量</h3><p>变量在makefile中定义的名字，用来代替一个文本字符串，该文本字符串成为变量的值。变量名是大小写敏感的。在makefile中定义变量有两种方式：一中是递归展开，另一种是简单方式。引用变量VAR的值的格式为$(VAR)。<br>递归展开方式的定义格式为：VAR=var。递归展开方式定义的变量实在引用该变量时进行替换的，即如果该变量包含了对其他变量的引用，则在引用该变量时一次性将内嵌变量全部展开。<br>简单展开变量的定义格式：VAR:=var。简单扩展类型变量的值在定义处展开，并且只展开一次，因此它不包含对任何其他的变量的引用，从而消除了嵌套引用。</p>
<p>下面给出一个使用了变量的makefile例子，这里用OBJS代替main.o 和add.o，用CC代替gcc,用CFLAGS代替”-Wall -O -g”。这样在以后修改时，就可以只修改变量定义，而不需要修改下面的引用实体，从而大大简化了维护makefile的工作量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS=main.o add.o</span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS=-Wall -O -g</span><br><span class="line"></span><br><span class="line">add:$(OBJS)</span><br><span class="line">	$(CC) $(OBJS) -o add</span><br><span class="line">main.o : main.c</span><br><span class="line">	$(CC) $(CFLAGS) -c main.c -o main.o</span><br><span class="line">add.o : add.c</span><br><span class="line">	$(CC) $(CFLAGS) -c add.c -o add.o</span><br><span class="line">    </span><br><span class="line">clean: </span><br><span class="line">	rm *.o</span><br></pre></td></tr></table></figure>
<p>可以看到，此处变量是以递归展开方式定义的。</p>
<blockquote>
<p>makefile 中的变量分为用户自定义变量、预定义变量、自动变量及环境变量。</p>
</blockquote>
<p>OBJS 就是用户自定义变量。未经用户定义，在makefile中默认存在的变量则为预定义变量和自动变量，其中部分有默认值，当然用户可以对其修改。<br>预定义变量包含了常见编译器、汇编器的名称及其编译选项。下表列出了常见的预定义变量及其部分默认值。</p>
<table>
<thead>
<tr>
<th>预定义变量</th>
<th>名称或选项</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AR</td>
<td>库文件维护程序的名称</td>
<td>ar</td>
</tr>
<tr>
<td>AS</td>
<td>汇编程序的名称</td>
<td>as</td>
</tr>
<tr>
<td>CC</td>
<td>C 编译器的名称</td>
<td>cc</td>
</tr>
<tr>
<td>CPP</td>
<td>C 预编译器的名称</td>
<td>$(CC) -E</td>
</tr>
<tr>
<td>CXX</td>
<td>C++ 编译器的名称</td>
<td>g++</td>
</tr>
<tr>
<td>FC</td>
<td>Fortran 编译器的名称</td>
<td>f77</td>
</tr>
<tr>
<td>RM</td>
<td>文件删除程序的名称</td>
<td>rm -f</td>
</tr>
<tr>
<td>CFLAGS</td>
<td>C 编译器的选项</td>
<td>无</td>
</tr>
<tr>
<td>CXXFLAGS</td>
<td>C++ 编译器的选项</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>由于常见的GCC编译语句通常包含了目标文件和依赖文件，而这些文件在makefile文件中的依赖关系一行已经有所体，因此，为了进一步简化makefile的编写，引入了自动变量。<strong>自定变量</strong>通常可以代表编译语句的目标文件和依赖文件等，并且具有本地含义。下表中列出了makefile 中常见的自动变量。</p>
<table>
<thead>
<tr>
<th>自定变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$*</td>
<td>不包含扩展名的目标文件名称</td>
</tr>
<tr>
<td>$+</td>
<td>所有的依赖文件，以空格分开，并以出现的先后为序</td>
</tr>
<tr>
<td>$&lt;</td>
<td>第一个依赖文件的名称</td>
</tr>
<tr>
<td>$?</td>
<td>所有时间戳比目标文件晚的依赖文件，并以空格分开</td>
</tr>
<tr>
<td>$@</td>
<td>目标文件的完整名称</td>
</tr>
<tr>
<td>$^</td>
<td>所有不重复的依赖文件，以空格分开</td>
</tr>
<tr>
<td>$%</td>
<td>如果目标是归档成员，则该变量表示目标文件的归档成员名称</td>
</tr>
</tbody>
</table>
<p>自动变量的书写比较难记，但是在熟练了之后会非常方便。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS=main.o add.o</span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS=-Wall -O -g</span><br><span class="line"></span><br><span class="line">add:$(OBJS)</span><br><span class="line">	$(CC) $^ -o $@</span><br><span class="line">main.o : main.c</span><br><span class="line">	$(CC) $(CFLAGS) -c $&lt; -o $@</span><br><span class="line">add.o : add.c</span><br><span class="line">	$(CC) $(CFLAGS) -c $&lt; -o $@</span><br><span class="line">    </span><br><span class="line">clean: </span><br><span class="line">	rm *.o</span><br></pre></td></tr></table></figure></p>
<p>另外，在makefile中还可以使用环境变量，使用环境变量的方法相对比较简单，make在启动时会自动读取系统当前已经定义的环境变量，并且会创建与之具有相同名称和数值的变量。但是，如果用户在makefile中定义了相同名称的变量，则用户自定义变量将覆盖同名的环境变量。</p>
<h3 id="3-5_makefile_与条件语句">3.5 makefile 与条件语句</h3><p>条件语句可以根据一个变量的值来控制 make 执行或者忽略 Makefile 的特定部分。条件语句可以是两个不同变量、或者变量和常量值的比较。要注意的是：条件语句只能用于控制 make 实际执行的makefile 文件部分，它不能控制规则的 shell 命令执行过程。Makefile 中使用条件控制可以做到处理的灵活性和高效性。</p>
<p>1.条件语句</p>
<p>首先我们来看一个使用条件判断的 Makefile 例子；对变量“CC”进行判断，其值如果是“gcc”那么在程序连接时使用库“libgnu.so”或者“libgnu.a”，否则不链接任何库。Makefile 中的条件判断部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line">foo: $(objects)  </span><br><span class="line">ifeq ($(CC),gcc)  </span><br><span class="line">	$(CC) -o foo $(objects) $(libs_for_gcc)  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">	$(CC) -o foo $(objects) $(normal_libs)  </span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>该条件包含了三个指令：ifeq、else 和 endif。ifeq 指令时条件语句的开始，并且指明条件。它包含两个参数，被逗号隔开，并被扩在圆括号内。运行时首先将两个参数变量进行替换，然后进行比较。</p>
<p>上面的例子一种更简洁的实现方式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu  </span><br><span class="line">normal_libs =  </span><br><span class="line">ifeq ($(CC),gcc)  </span><br><span class="line">	libs=$(libs_for_gcc)  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">	libs=$(normal_libs)  </span><br><span class="line">endif  </span><br><span class="line"></span><br><span class="line">foo: $(objects)  </span><br><span class="line">	$(CC) -o foo $(objects) $(libs)</span><br></pre></td></tr></table></figure>
<p>2.条件语句的语法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conditional-directive</span><br><span class="line">     text-<span class="keyword">if</span>-ture</span><br><span class="line"> endif</span><br></pre></td></tr></table></figure></p>
<p>“text-if-true” 可以是任何文本行，在条件为真是它被认为是makefile中的一部分；如果为假则被忽略。</p>
<p>完整条件语句的语法为：<br>    conditional-directive<br>        text-if-ture<br>    else<br>        test-if-false<br>    endif </p>
<p>conditiona-directive 有如下的一些条件语句：</p>
<ul>
<li>ifeq(arg1, arg2) 测试arg1， arg2 是否相等</li>
<li>ifdef variable-name 测试变量variable-name是否被定义过</li>
<li>ifndef 与ifdef 的功能恰好相反，ifndef 用来判断变量是否没有被定义</li>
</ul>
<h3 id="3-6_makefile_与函数">3.6 makefile 与函数</h3><p>在makefile中可以使用函数来处理变量从而让命令或规则更为灵活和智能。make所支持的函数不算多，但是已经足够使用了。函数调用后，函数的返回值可以当作变量来使用。</p>
<ol>
<li>函数的用法<br>函数调用很像变量的使用，也是以“$”来标识的，语法如下：<br> <code>$(&lt;function&gt;&lt;arguments&gt;)</code><br>或者是<br> <code>${&lt;function&gt;&lt;arguments&gt;}</code><br>其中，<function> 是函数名，arguments是函数参数，参数间以逗号分隔，而函数名和参数之间以空格分隔。<br>看下面的例子：</function></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= $(empty) $(empty)</span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= $(subst $(space),$(comma),$(foo)) </span><br><span class="line"></span><br><span class="line">.PHNOY:clearn</span><br><span class="line">clearn:</span><br><span class="line">	@echo $(bar)</span><br></pre></td></tr></table></figure>
<p>这个例子中，“\$(comma)”的值是一个逗号，”\$(space)”使用”\$(empty)”定义了一个空格，“\$(foo)” 的值是“a b c”, “\$(bar)”的定义调用l函数subst,这是一个替换函数，这个函数有三个参数，第一个参数是被替换字符串，第二个参数是替换字符串，第三个参数是需要执行替换操作的字串。这个函数将“\$(foo)”中的空格替换成逗号，所以“\$(bar)”的值为“a,b,c”。<br>其他一些函数：</p>
<ol>
<li><code>$(subst FROM,TO,TEXT)</code><br>函数名称：字符串替换函数—subst。<br>函数功能：把字串“TEXT”中的“FROM”字符替换为“TO”。<br>返回值：替换后的新字符串。<br>示例：<br><code>$(subst ee,EE,feet on the street)</code><br>替换“feet on the street”中的“ee”为“EE”，结果得到字符串“fEEt on the strEEt”。</li>
<li><code>$(strip STRINT)</code><br>函数名称：去空格函数—strip。<br>函数功能：去掉字串（若干单词，使用若干空字符分割）“STRINT”开头和结尾的<br>空字符，并将其中多个连续空字符合并为一个空字符。<br>返回值：无前导和结尾空字符、使用单一空格分割的多单词字符串。<br>函数说明：空字符包括空格、[Tab]等不可显示字符。<br>示例：<br><code>STR = a b c</code><br><code>LOSTR = $(strip $(STR))</code><br>结果是“a b c”。<br>“strip”函数经常用在条件判断语句的表达式中，确保表达式比较的可靠和健壮！</li>
<li><code>$(findstring FIND,IN)</code><br>函数名称：查找字符串函数—findstring。<br>函数功能：搜索字串“IN”，查找“FIND”字串。<br>返回值：如果在“IN”之中存在“FIND”，则返回“FIND”，否则返回空。<br>函数说明：字串“IN”之中可以包含空格、[Tab]。搜索需要是严格的文本匹配。<br>示例：<br><code>$(findstring a,a b c)
$(findstring a,b c)</code><br>第一个函数结果是字“a”；第二个值为空字符。</li>
<li>shell函数<br>shell 函数，它的参数对应的就是shell的命令，它的反引号“`”具有相同的功能。shell 函数将执行系统命令后的输出作为返回值，可以用系统命令及字符串处理命令awk、sed 等命令来生成一个变量。例如：</li>
</ol>
<p><code>contents := $(shell cat foo)</code><br>将变量“contents”赋值为文件“foo”的内容，文件中的换行符在变量中使用空格代<br>替。</p>
<h2 id="4-_伪目标">4. 伪目标</h2><p>伪目标是这样一个目标：它不代表一个真正的文件名，在执行 make 时可以指定这个目标来执行其所在规则定义的命令，有时也可以将一个伪目标称为标签。</p>
<p>使用伪目标有两点原因： 1. 避免在我们的 Makefile 中定义的只执行命令的目标（此目标的目的为了执行执行一些列命令，而不需要创建这个目标）和工作目录下的实际文件出现名字冲突。 2. 提高执行 make 时的效率，特别是对于一个大型的工程来说，编译的效率也许你同样关心。以下就这两个问题我们进行分析讨论：</p>
<p>1.如果我们需要书写这样的一个规则：规定所定义的命令不是去创建目标文件，而是通过make命令行明确指定它来执行一些特定的命令。像常见的clean 目标：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm -rf *.o temp</span><br></pre></td></tr></table></figure>
<p>规则中“ rm”不是创建文件“ clean”的命令，而是删除当前目录下的所有.o 文件和 temp文件。当工作目录下不存在“ clean”这个文件时，我们输入“ make clean”，“ rm *.o temp”总会被执行。这是我们的初衷。</p>
<p>但是如果在当前工作目录下存在文件“clean”，情况就不一样了，同样我们输入<br>“ make clean”，由于这个规则没有任何依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令，因此命令“rm”将不会被执行。这并不是我们的初衷。为了解决这个问题，我们需要将目标“clean”声明为伪目标。将一个目标声明为伪目标的方法是将它作为特殊目标<strong>.PHONY</strong>的依赖。</p>
<p>这样目标“clean”就被声明为一个伪目标，无论在当前目录下是否存在“clean”这个文件。我们输入”make clean”之后。“rm”命令都会被执行。而且，当一个目标被声明为伪目标后，make 在执行此规则时不会去试图去查找隐含规则来创建它。这样也提高了 make 的执行效率，同时也不用担心由于目标和文件名重名而使我们的期望失败。在书写伪目标规则时，首先需要声明目标是一个伪目标，之后才是伪目标的规则定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">.PHONY:clean    </span><br><span class="line">clean:  </span><br><span class="line">    rm -rf *.o temp</span><br></pre></td></tr></table></figure>
<p>2.伪目标的另外一种使用场合是在 make 的并行和递归执行过程中。此情况下一般会存在一个变量，定义为所有需要 make 的子目录。对多个目录进行 make 的实现方 式可以是：在一个规则的命令行中使用 shell 循环来完成。</p>
<p>在 Makefile 中，一个伪目标可以有自己的依赖（可以是一个或者多个文件、一个或者多个伪目标）。在一个目录下如果需要创建多个可执行程序，我们可以将所有程序的重建规则在一个 Makefile 中描述。因为 Makefile 中第一个目标是“终极目标”，约定的做法是使用一个称为<strong>“all”</strong>的伪目标来作为终极目标，它的依赖文件就是那些需要创建的程序。下面就是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#sample Makefile</span></span><br><span class="line">all:prog1 prog2 prog3</span><br><span class="line">.PHONY:all</span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line">prog2 : prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>
<p>执行 make 时，目标“ all”被作为终极目标。为了完成对它的更新， make 会创建（不存在）或者重建（已存在）目标“ all”的所有依赖文件（ prog1、 prog2 和 prog3）。当需要单独更新某一个程序时，我们可以通过 make 的命令行选项来明确指定需要重建的程序。（例如：“ make prog1”）。</p>
<h2 id="5-_makefile_中的隐含规则">5. makefile 中的隐含规则</h2><p>在使用make编译.c源文件时，编译.c源文件规则的命令可以不用明确给出。这是因为make本身存在一个默认的规则，能够自动完成对.c文件的编译并生成对应的.o文件。它执行命令“cc -c”来编译.c源文件。在Makefile中我们只需要给出需要重建的目标文件。</p>
<p>“<em>隐含规则</em>”为 make 提供了重建一类目标文件通用方法，不需要在 Makefile 中明确地给出重建特定目标文件所需要的细节描述。例如：典型地；make 对 C 文件的编译过程是由.c 源文件编译生成.o 目标文件。当 Makefile 中出现一个.o 文件目标时，make 会使用这个通用的方式将后缀为.c 的文件编译称为目标的.o 文件。另外，在 make 执行时根据需要也可能是用多个隐含规则。比如：make 将从一个.y文件生成对应的.c 文件，最后再生成最终的.o 文件。就是说，只要目标文件名中除后缀以外其它部分相同，make 都能够使用若干个隐含规则来最终产生这个目标文件（当然最原始的那个文件必须存在）。例如；可以在 Makefile 中这样来实现一个规则：“foo : foo.h”，只要在当前目录下存在“foo.c”这个文件，就可以生成“foo”可执行文件。</p>
<p>内嵌的“隐含规则”在其所定义的命令行中，会使用到一些变量（通常也是内嵌变量）。我们可以通过改变这些变量的值来控制隐含规则命令的执行情况。例如：内嵌变量“CFLAGS”代表了 gcc 编译器编译源文件的编译选项，我们就可以在 Makefile 中 重新定义它，来改变编译源文件所要使用的参数。<br>看下面的例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># sample Makefile</span></span><br><span class="line">CUR_DIR = $(shell pwd)</span><br><span class="line">INCS := $(CUR_DIR)/include</span><br><span class="line">CFLAGS := -Wall –I$(INCS)</span><br><span class="line">EXEF := foo bar</span><br><span class="line">.PHONY : all clean</span><br><span class="line">all : $(EXEF)</span><br><span class="line">foo : foo.c</span><br><span class="line">foo : CFLAGS+=-O2</span><br><span class="line">bar : bar.c</span><br><span class="line">bar : CFLAGS+=-g</span><br><span class="line"></span><br><span class="line">$(EXEF) : debug.h</span><br><span class="line">    $(CC) $(CFLAGS) $(addsuffix .c,$@) –o $@</span><br><span class="line">clean :</span><br><span class="line">    $(RM) *.o *.d $(EXES)</span><br></pre></td></tr></table></figure></p>
<p>对应使用简化规则后的makefile 文件如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># sample Makefile</span></span><br><span class="line">CUR_DIR = $(shell pwd)</span><br><span class="line">INCS := $(CUR_DIR)/include</span><br><span class="line">CFLAGS := -Wall –I$(INCS)</span><br><span class="line">EXEF := foo bar</span><br><span class="line">.PHONY : all clean</span><br><span class="line">all : $(EXEF)</span><br><span class="line">foo : CFLAGS+=-O2</span><br><span class="line">bar : CFLAGS+=-g</span><br><span class="line">clean :</span><br><span class="line">    $(RM) *.o *.d $(EXES)</span><br></pre></td></tr></table></figure></p>
<p>以下是一些常见的隐含规则：</p>
<ol>
<li>编译C程序<br>“N.o”自动由“N.c”生成，执行命令为<code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code>。</li>
<li>编译C++程序<br>“N.o”自动由“N.cc”或者“N.C”生成，执行命令为<code>$(CXX) -c $(CPPFLAGS)
$(CFLAGS)</code>。建议使用“.cc”作为C++源文件的后缀，而不是“.C”。</li>
<li>编译Fortran/Ratfor程序<br>“N.o”自动由“N.r”、“N.F”或者“N.f” 生成，根据源文件后缀执行对应的<br>命令：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.f — “$(FC) –c $(FFLAGS)</span><br><span class="line">.F — “$(FC) –c $(FFLAGS) $(CPPFLAGS)</span><br><span class="line">.r — “$(FC) –c $(FFLAGS) $(RFLAGS)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-_后记">6. 后记</h2><p>下面是我写的一个代码的makefile文件，定义的object变量太长了，以至于后面对objects中每个文件的编译都要写两行，不知道有没有行数能够循环遍历object，以后有时间再考虑吧。</p>
<p>另外就是还有automake 和autoconf 工具，也需要了解和学习。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=g++&#10;OBJES=elfReader.o elfReader_header.o elfReader_Dump.o \&#10;&#9;  elfReader_RelSym.o elfReader_Section.o elfReader_Symbol.o&#10;Flags= -Wall&#10;&#10;&#10;all:elfReader&#10;.PHONY:all clean&#10;&#10;elfReader:$(OBJES)&#10;&#9;$(CC) -o $@ $^ &#10;elfReader.o:elfReader.cpp elfReader.h&#10;&#9;$(CC) -c $&#60;&#10;elfReader_header.o:elfReader_header.cpp elfReader.h&#10;&#9;$(CC) -c $&#60;&#10;elfReader_Dump.o:elfReader_Dump.cpp elfReader.h&#10;&#9;$(CC) -c $&#60;&#10;elfReader_RelSym.o:elfReader_RelSym.cpp elfReader.h&#10;&#9;$(CC) -c $&#60;&#10;elfReader_Section.o:elfReader_Section.cpp elfReader.h&#10;&#9;$(CC) -c $&#60;&#10;elfReader_Symbol.o:elfReader_Symbol.cpp elfReader.h&#10;&#9;$(CC) -c $&#60;&#10;&#10;clean:&#10;&#9;rm *.o</span><br></pre></td></tr></table></figure>
<p> 这个程序主要是为了把二进制代码翻译为汇编代码，好吧，我真是闲的没事才干这么无聊的事情。<br>翻译还没有写完，以后有时间会继续更新。</p>
<blockquote>
<p>项目的github 链接为：<a href="https://github.com/ylwdream/readELF" target="_blank" rel="external">readelf</a> </p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li><a href="http://www.chinaunix.net/old_jh/23/408225.html" target="_blank" rel="external">跟我一起写makefile</a></li>
<li><a href="">Linux 编程80例详解</a></li>
<li><a href="http://www.mcuol.com/download/upfile/20080109021058_GNU_make_zh_CN.pdf" target="_blank" rel="external">GNU make中文手册</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_make_的工作原理">1. make 的工作原理</h2><p>make 工具最基本的功能是调用makefile文件，通过makefile文件来描述程序编译的整个过程，不必每次输入gcc 或者 g++ 等命令来完成编译工作。<br>makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。<br>]]>
    
    </summary>
    
      <category term="shell" scheme="http://ylwhere.tk/tags/shell/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[入口函数和程序初始化]]></title>
    <link href="http://ylwhere.tk/2015/05/31/%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://ylwhere.tk/2015/05/31/入口函数和程序初始化/</id>
    <published>2015-05-31T02:22:56.000Z</published>
    <updated>2015-06-03T03:07:18.593Z</updated>
    <content type="html"><![CDATA[<h2 id="入口函数">入口函数</h2><p>程序的入口函数，站在程序员的角度来说，往往会认为程序是从main函数来开始执行的，可是有一个问题是，那么main函数是由谁调用的呢？我们知道，在C++中全局变量的构造函数是在调用main之前就已经被调用构造函数而初始化完毕，那么这个机制是如何实现的？</p>
<p>我们知道在shell脚本中执行一个程序，shell会接收输入的命令，利用<code>fork()</code>函数生成一个子进程，然后等待子进程运行完程序后返回。那么<code>fork()</code>函数又是怎么实现的，和程序的装载运行有什么关系？</p>
<a id="more"></a>
<h2 id="fork_函数">fork 函数</h2><p>先从<code>fork()</code>函数说起，它默认会创建一个新的进程，在父进程中返回值为子进程的pid，在子进程中返回的是0。</p>
<p>其实是子进程使用了和父进程一样的页表，导致两个进程所有数据都是一模一样的，没有任何差别。当然，在子进程的页表里会有特殊标记，使得当子进程需要写这段内存时（读的时候任何事情都不会发生），内核会将要写的这一页复制一份新的给子进程。是谓「写时复制」。</p>
<blockquote>
<p>利用<code>man fork</code> 可以看到下面的解释。</p>
</blockquote>
<p><img src="/img/blog/fork.PNG" alt=""></p>
<p>可以看到fork是对父进程的复制，只是一些锁、等待队列等不一样。<br>那么返回值为什么在父子进程中不一样的。</p>
<p>“引用一位网友的话来解释fpid的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0.”</p>
<p>其实在linux中fork返回值的处理交给了一个do_fork的函数，这个函数根据传入的值，然后会分别在子进程和父进程中执行，从而返回两次不同的值，具体过程和上面所说的实现思想差不多。</p>
<p>可以参考如下的分析：<br><a href="http://blog.csdn.net/yunsongice/article/details/5508242" target="_blank" rel="external">do_fork() 详解</a></p>
<h2 id="程序的装载">程序的装载</h2><p><code>fork()</code> 创建一个新进程，然后新的进程调用<code>execve()</code>系统调用执行指定的 ELF 文件。<code>execve()</code>函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replace the current process, executing PATH with arguments ARGV and</span><br><span class="line"> environment ENVP.  ARGV and ENVP are terminated by NULL pointers. </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">execve</span> <span class="params">(__const <span class="keyword">char</span> *__path, <span class="keyword">char</span> *__const __argv[],</span><br><span class="line"> 				   <span class="keyword">char</span> *__const __envp[])</span> __THROW __<span class="title">nonnull</span> <span class="params">((1, 2)</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>在进入了<code>execve()</code> 系统调用后，Linux 内核就开始真正的装载工作。在内核中，<code>execve()</code>调用相应的入口函数是<code>sys_execve()</code>,在Porcess32.c文件中可以查找到。主要内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_execve</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">char</span> *filename;</span><br><span class="line"></span><br><span class="line">	filename = getname((<span class="keyword">char</span> __user *) regs-&gt;bx);</span><br><span class="line">	error = PTR_ERR(filename);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(filename))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	error = do_execve(filename,</span><br><span class="line">			(<span class="keyword">char</span> __user * __user *) regs-&gt;cx,</span><br><span class="line">			(<span class="keyword">char</span> __user * __user *) regs-&gt;dx,</span><br><span class="line">			regs);</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中———user是给编译器检查用的，这里可以理解为<code>#define __user</code>，定义为空。得到文件的目录位置然后调用<code>do_execve()</code>来解析filename。<br><code>pt_regs</code> 是寄存器的结构体。作为函数的参数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pt_regs &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> si;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> di;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ds;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> es;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> gs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> orig_ax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>do_execve()</code> 首先读取文件的前128字节。判断文件的类型和。Linux支持的文件格式不止ELF一种，还有a.out和“#！”开始的脚本程序。每种可执行文件的开头几个字节都很特殊，特别是开头的4个字节，常常作被称为魔数。比如ELF文件的开头4个字节为0x7F,’e’,’l’,’f’;而java的可执行文件格式的头4个字节为’c’,’a’,’f’,’e’;如果被执行的是脚本程序，那么开头往往是“#!/bin/sh”，这时候开头的两个字节’#’,’!’就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">char</span> * filename,</span><br><span class="line">	<span class="keyword">char</span> __user *__user *argv,</span><br><span class="line">	<span class="keyword">char</span> __user *__user *envp,</span><br><span class="line">	<span class="keyword">struct</span> pt_regs * regs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> linux_binprm *bprm;</span><br><span class="line">	<span class="keyword">struct</span> file *file;</span><br><span class="line">	<span class="keyword">struct</span> files_struct *displaced;</span><br><span class="line">	<span class="keyword">bool</span> clear_in_exec;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = unshare_files(&amp;displaced);             <span class="comment">//检查文件状态，displaced为NULL。</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_ret;</span><br><span class="line"></span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	bprm = kzalloc(<span class="keyword">sizeof</span>(*bprm), GFP_KERNEL);      <span class="comment">//用kzalloc分配空间。</span></span><br><span class="line">	<span class="keyword">if</span> (!bprm)</span><br><span class="line">		<span class="keyword">goto</span> out_files;</span><br><span class="line"></span><br><span class="line">	retval = prepare_bprm_creds(bprm);    			<span class="comment">//检测锁的状态，设置新process的key值</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">	retval = check_unsafe_exec(bprm);				<span class="comment">//检查是否可以安全的执行</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line">	clear_in_exec = retval;</span><br><span class="line">	current-&gt;in_execve = <span class="number">1</span>;							<span class="comment">/* Tell the LSMs that the process is doing an</span><br><span class="line">				 * execve */</span></span><br><span class="line"></span><br><span class="line">	file = open_exec(filename);						<span class="comment">//打开可执行文件</span></span><br><span class="line">	retval = PTR_ERR(file);							<span class="comment">//把file地址转换为long型</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file))								<span class="comment">//检测地址值是否合法</span></span><br><span class="line">		<span class="keyword">goto</span> out_unmark;</span><br><span class="line"></span><br><span class="line">	sched_exec();									<span class="comment">//调度策略，平衡每个等待运行的进程的机会</span></span><br><span class="line"></span><br><span class="line">	bprm-&gt;file = file;</span><br><span class="line">	bprm-&gt;filename = filename;</span><br><span class="line">	bprm-&gt;interp = filename;			</span><br><span class="line"></span><br><span class="line">	retval = bprm_mm_init(bprm);					<span class="comment">//创建一个暂时的栈空间</span></span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_file;</span><br><span class="line"></span><br><span class="line">	bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);		<span class="comment">//计算argv参数的个数</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = bprm-&gt;argc) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);		<span class="comment">//环境变量的个数</span></span><br><span class="line">	<span class="keyword">if</span> ((retval = bprm-&gt;envc) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = prepare_binprm(bprm);					<span class="comment">// Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);  <span class="comment">//拷贝参数到暂时的栈空间</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	bprm-&gt;exec = bprm-&gt;p;</span><br><span class="line">	retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	current-&gt;flags &amp;= ~PF_KTHREAD;</span><br><span class="line">	retval = search_binary_handler(bprm,regs);			<span class="comment">//判断魔数，调用相应的装载程序</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* execve succeeded */</span></span><br><span class="line">	current-&gt;fs-&gt;in_exec = <span class="number">0</span>;</span><br><span class="line">	current-&gt;in_execve = <span class="number">0</span>;</span><br><span class="line">	acct_update_integrals(current);</span><br><span class="line">	free_bprm(bprm);</span><br><span class="line">	<span class="keyword">if</span> (displaced)</span><br><span class="line">		put_files_struct(displaced);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看结构体,其中<code>BINPRM_BUF_SIZE = 128</code>可以在<code>binfmts.h (D:\开源代码\linux kernel\linux-2.6.32.65\include\linux)</code>查找到。    <code>search_binary_handler()</code>会通过判断文件头部的魔数来确定文件的格式，并且调用相应的装载处理过程。比如ELF可执行文件的装载处理过程叫做<code>load_elf_binary</code>;装载可执行脚本的处理过程为<code>load_script()</code>.<code>load_elf_binary</code>被定义在<code>fs/binfmt_elf.c</code>中。 它的主要步骤是：</p>
<ul>
<li>1.检测ELF可执行文件的有效性，比如魔数、程序头表中的数量。</li>
<li>2.寻找动态链接的“.interp” 段，设置动态链接器的路径。</li>
<li>3.根据ELF可执行文件的程序表头的描述，对ELF文件进行映射，比如代码，数据，只读数据</li>
<li>4.初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址。</li>
<li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序的入口点就是ELF文件的e_entry所指的地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * This structure is used to hold the arguments that are used when loading binaries.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> linux_binprm&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[BINPRM_BUF_SIZE];</span><br><span class="line">	<span class="keyword">struct</span> vm_area_struct *vma;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vma_pages;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> mm_struct *mm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> p; <span class="comment">/* current top of mem */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">		cred_prepared:<span class="number">1</span>,<span class="comment">/* true if creds already prepared (multiple</span><br><span class="line">				 * preps happen for interpreters) */</span></span><br><span class="line">		cap_effective:<span class="number">1</span>;<span class="comment">/* true if has elevated effective capabilities,</span><br><span class="line">				 * false if not; except for init which inherits</span><br><span class="line">				 * its parent's caps anyway */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> recursion_depth;</span><br><span class="line">	<span class="keyword">struct</span> file * file;</span><br><span class="line">	<span class="keyword">struct</span> cred *cred;	<span class="comment">/* new credentials */</span></span><br><span class="line">	<span class="keyword">int</span> unsafe;		<span class="comment">/* how unsafe this exec is (mask of LSM_UNSAFE_*) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> per_clear;	<span class="comment">/* bits to clear in current-&gt;personality */</span></span><br><span class="line">	<span class="keyword">int</span> argc, envc;</span><br><span class="line">	<span class="keyword">char</span> * filename;	<span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line">	<span class="keyword">char</span> * interp;		<span class="comment">/* Name of the binary really executed. Most</span><br><span class="line">				   of the time same as filename, but could be</span><br><span class="line">				   different for binfmt_&#123;misc,script&#125; */</span></span><br><span class="line">	<span class="keyword">unsigned</span> interp_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> interp_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> loader, exec;</span><br></pre></td></tr></table></figure>
<p>当<code>load_elf_binary()</code>执行完毕，返回至<code>do_execve()</code>再返回至<code>sys_execve()</code>，上面的第5步中已经把系统调用的返回地址改为了被装载的ELf程序的入口地址了，所以EIP寄存器直接跳转到了ELF程序的入口地址。于是新的程序开始执行，ELF文件装载完毕。</p>
<blockquote>
<p>总结就是: <code>execve()--&gt;sys_execve()--&gt;do_execve()--&gt;search_binary_hander()-&gt;load_elf_binary()</code></p>
</blockquote>
<h2 id="程序入口函数">程序入口函数</h2><p>先看下面的一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> v;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> g = foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"bye!"</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; g &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>用g++ -S test.c -o test.S</code> 可以得到下面的汇编指令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.LFE1020:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.type	_Z41__static_initialization_and_destruction_0ii, @function</span><br><span class="line">_Z41__static_initialization_and_destruction_0ii:</span><br><span class="line">.LFB1057:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">	.cfi_offset <span class="number">5</span>, -<span class="number">8</span></span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">5</span></span><br><span class="line">	subl	$<span class="number">8</span>, %esp</span><br><span class="line">	cmpl	$<span class="number">1</span>, <span class="number">8</span>(%ebp)</span><br><span class="line">	jne	.L6</span><br><span class="line">	cmpl	$<span class="number">65535</span>, <span class="number">12</span>(%ebp)</span><br><span class="line">	jne	.L6</span><br><span class="line">	subl	$<span class="number">12</span>, %esp</span><br><span class="line">	pushl	$v</span><br><span class="line">	call	_ZNSsC1Ev</span><br><span class="line">	addl	$<span class="number">16</span>, %esp</span><br><span class="line">	subl	$<span class="number">4</span>, %esp</span><br><span class="line">	pushl	$__dso_handle</span><br><span class="line">	pushl	$v</span><br><span class="line">	pushl	$_ZNSsD1Ev</span><br><span class="line">	call	__cxa_atexit</span><br><span class="line">	addl	$<span class="number">16</span>, %esp</span><br><span class="line">	subl	$<span class="number">12</span>, %esp</span><br><span class="line">	pushl	$_ZStL8__ioinit</span><br><span class="line">	call	_ZNSt8ios_base4InitC1Ev</span><br><span class="line">	addl	$<span class="number">16</span>, %esp</span><br><span class="line">	subl	$<span class="number">4</span>, %esp</span><br><span class="line">	pushl	$__dso_handle</span><br><span class="line">	pushl	$_ZStL8__ioinit</span><br><span class="line">	pushl	$_ZNSt8ios_base4InitD1Ev</span><br><span class="line">	call	__cxa_atexit</span><br><span class="line">	addl	$<span class="number">16</span>, %esp</span><br><span class="line">	call	_Z3foov</span><br><span class="line">	fstpl	g</span><br><span class="line">.L6:</span><br><span class="line">	leave</span><br><span class="line">	.cfi_restore <span class="number">5</span></span><br><span class="line">	.cfi_def_cfa <span class="number">4</span>, <span class="number">4</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br></pre></td></tr></table></figure></p>
<p>可以看到汇编指令对于全局变量首先会注册到<code>_Z41__static_initialization_and_destruction_0ii</code>初始化。<br>glibc的程序入口为`_start（这个入口是由链接器的脚本所制定的）_start由汇编实现，并且和平台相关。<br>i386的_start实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the canonical entry point, usually the first thing in the text</span><br><span class="line">   segment.  The SVR4/i386 ABI (pages 3-31, 3-32) says that when the entry</span><br><span class="line">   point runs, most registers' values are unspecified, except for:</span><br><span class="line"></span><br><span class="line">   %edx		Contains a function pointer to be registered with `atexit'.</span><br><span class="line">		This is how the dynamic linker arranges to have DT_FINI</span><br><span class="line">		functions called for shared libraries that have been loaded</span><br><span class="line">		before this code runs.</span><br><span class="line"></span><br><span class="line">   %esp		The stack contains the arguments and environment:</span><br><span class="line">		0(%esp)			argc</span><br><span class="line">		4(%esp)			argv[0]</span><br><span class="line">		...</span><br><span class="line">		(4*argc)(%esp)		NULL</span><br><span class="line">		(4*(argc+1))(%esp)	envp[0]</span><br><span class="line">		...</span><br><span class="line">					NULL</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.globl _start</span><br><span class="line">	.type _start,@function</span><br><span class="line">_start:</span><br><span class="line">	<span class="comment">/* Clear the frame pointer.  The ABI suggests this be done, to mark</span><br><span class="line">	   the outermost frame obviously.  */</span></span><br><span class="line">	xorl %ebp, %ebp</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Extract the arguments as encoded on the stack and set up</span><br><span class="line">	   the arguments for `main': argc, argv.  envp will be determined</span><br><span class="line">	   later in __libc_start_main.  */</span></span><br><span class="line">	popl %esi		<span class="comment">/* Pop the argument count.  */</span></span><br><span class="line">	movl %esp, %ecx		<span class="comment">/* argv starts just at the current stack top.*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Before pushing the arguments align the stack to a 16-byte</span><br><span class="line">	(SSE needs 16-byte alignment) boundary to avoid penalties from</span><br><span class="line">	misaligned accesses.  Thanks to Edward Seidl &lt;seidl@janed.com&gt;</span><br><span class="line">	for pointing this out.  */</span></span><br><span class="line">	andl $<span class="number">0xfffffff0</span>, %esp</span><br><span class="line">	pushl %eax		<span class="comment">/* Push garbage because we allocate</span><br><span class="line">				   28 more bytes.  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Provide the highest stack address to the user code (for stacks</span><br><span class="line">	   which grow downwards).  */</span></span><br><span class="line">	pushl %esp</span><br><span class="line"></span><br><span class="line">	pushl %edx		<span class="comment">/* Push address of the shared library</span><br><span class="line">				   termination function.  */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Push address of our own entry points to .fini and .init.  */</span></span><br><span class="line">	pushl $__libc_csu_fini</span><br><span class="line">	pushl $__libc_csu_init</span><br><span class="line"></span><br><span class="line">	pushl %ecx		<span class="comment">/* Push second argument: argv.  */</span></span><br><span class="line">	pushl %esi		<span class="comment">/* Push first argument: argc.  */</span></span><br><span class="line"></span><br><span class="line">	pushl $main</span><br><span class="line">	call __libc_start_main</span><br></pre></td></tr></table></figure></p>
<p>实际执行代码的函数是<code>__libc_start_main</code>,函数的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">STATIC <span class="keyword">int</span> <span class="title">LIBC_START_MAIN</span> <span class="params">(<span class="keyword">int</span> (*main)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span> **, <span class="keyword">char</span> **</span><br><span class="line">					 MAIN_AUXVEC_DECL)</span>,</span><br><span class="line">			    <span class="keyword">int</span> argc,</span><br><span class="line">			    <span class="keyword">char</span> **argv,</span><br><span class="line">#ifdef LIBC_START_MAIN_AUXVEC_ARG</span><br><span class="line">			    <span class="title">ElfW</span><span class="params">(auxv_t)</span> *auxvec,</span><br><span class="line">#endif</span><br><span class="line">			    __<span class="title">typeof</span> <span class="params">(main)</span> init,</span><br><span class="line">			    <span class="title">void</span> <span class="params">(*fini)</span> <span class="params">(<span class="keyword">void</span>)</span>,</span><br><span class="line">			    <span class="title">void</span> <span class="params">(*rtld_fini)</span> <span class="params">(<span class="keyword">void</span>)</span>,</span><br><span class="line">			    <span class="keyword">void</span> *stack_end)</span><br><span class="line">     __<span class="title">attribute__</span> <span class="params">((noreturn)</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>一共有7个参数，其中main由第一个参数传入，紧接着是argc和argv，出了mian的函数指针外，外部还要传入3个函数指针，分别是：</p>
<ul>
<li>init：main 调用前的初始化工作</li>
<li>fini：main 结束后的收尾工作</li>
<li>rtld_fini: 和动态加载有关的收尾工作</li>
<li>最后的stack_end 标明了栈底的位置，即最高的栈位置。</li>
</ul>
<p>libc_start_main中的关键函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the thread library at least a bit since the libgcc</span><br><span class="line">   functions are using thread functions if these are available and</span><br><span class="line">   we need to setup errno.  */</span></span><br><span class="line">__pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call the initializer of the libc.  This is only needed here if we</span><br><span class="line">   are compiling for the static library in which case we haven't</span><br><span class="line">   run the constructors in `_dl_start_user'.  */</span></span><br><span class="line">__libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line"><span class="keyword">if</span> (fini)</span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) fini, NULL, NULL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (init)</span><br><span class="line">  (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line">    <span class="comment">/* Run the program.  */</span></span><br><span class="line">    result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br></pre></td></tr></table></figure>
<p>在最后，main函数终于被调用，并退出。调用过程为<code>_start-&gt;_libc_start_main-&gt;exit-&gt;_exit</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line">	.type	_exit,@function</span><br><span class="line">	.global	_exit</span><br><span class="line">_exit:</span><br><span class="line">	movl	<span class="number">4</span>(%esp), %ebx</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Not available.  Now the old one.  */</span></span><br><span class="line">	movl	$__NR_exit, %eax</span><br><span class="line">	<span class="comment">/* Don't bother using ENTER_KERNEL here.  If the exit_group</span><br><span class="line">	   syscall is not available AT_SYSINFO isn't either.  */</span></span><br><span class="line">	<span class="keyword">int</span>	$<span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This must not fail.  Be sure we don't return.  */</span></span><br><span class="line">	hlt</span><br></pre></td></tr></table></figure></p>
<p>可以知道_exit的作用仅仅是调用exit这个系统调用。也就是说_exit调用后，进程就会直接结束。程序正常结束有两种情况，一种是mian函数的正常返回，另一种是调用exit推出。在——libc_start_main中可以看到，即使main返回了，exit也会被调用。exit是进程正常退出的必经之路。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/yunsongice/article/details/5508242" target="_blank" rel="external">do_fork() 详解</a></li>
<li><a href="">程序员的自我修养</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="入口函数">入口函数</h2><p>程序的入口函数，站在程序员的角度来说，往往会认为程序是从main函数来开始执行的，可是有一个问题是，那么main函数是由谁调用的呢？我们知道，在C++中全局变量的构造函数是在调用main之前就已经被调用构造函数而初始化完毕，那么这个机制是如何实现的？</p>
<p>我们知道在shell脚本中执行一个程序，shell会接收输入的命令，利用<code>fork()</code>函数生成一个子进程，然后等待子进程运行完程序后返回。那么<code>fork()</code>函数又是怎么实现的，和程序的装载运行有什么关系？</p>]]>
    
    </summary>
    
      <category term="compiler" scheme="http://ylwhere.tk/tags/compiler/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux Dynamic linking]]></title>
    <link href="http://ylwhere.tk/2015/05/24/linux-Dynamic-linking/"/>
    <id>http://ylwhere.tk/2015/05/24/linux-Dynamic-linking/</id>
    <published>2015-05-24T05:59:53.000Z</published>
    <updated>2015-07-03T10:46:38.001Z</updated>
    <content type="html"><![CDATA[<h2 id="动态链接">动态链接</h2><p>动态链接英文是Dynamic Linking，需要解决空间浪费和更新困难这两个问题。最简单的办法就是把程序的模块相互划分开来，形成独立的文件，而不再将他们静态的链接在一起。简单地讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接(Dynamic Linking)的基本思想。</p>
<p>动态链接还有一个特点，就是程序在运行时可以动态地选择加载各种程序模块，这个优点就是后来被人们用来制作程序的插件(plug-in)。</p>
<a id="more"></a>
<p>比如某个公司开发完成了某个产品,它按照一定的规则制定好程序的接口，其他公司或者开发者可以按照这种接口来编写符合要求的动态链接文件。该产品程序可以动态地载入各种第三方开发的模块，在程序运行时动态地链接，实现程序的扩展。</p>
<p>动态链接也有很多的问题令人烦恼和费解的地方。很常见的一个问题是，当程序所依赖的某个模块更新后，由于新的模块与旧的模块之间接口不兼容，导致了原来的程序无法运行。</p>
<h2 id="动态链接的基本实现">动态链接的基本实现</h2><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立的部分，在程序运行时才将他们链接在一起形成一个完成的程序，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。在linux 系统中，ELF动态链接文件被称为动态共享对象（DSO,Dynamic Shared Objects）,简称共享对象，他们一般都是以“.so”为扩展名的一些文件。而在windows系统中，动态链接文件被称为动态链接库(Dynamical Linking Library)，它们通常就是我们平时很常见的以“.dll”为扩展名的文件。</p>
<p>在Linux 中，常用的C语言库的运行库glibc，它的动态链接形式的版本保存在“/lib”目录下，文件名是“libc.so.6”。整个系统只保留一份C语言的动态链接文件。可以通过命令<code>ldd hello</code> 来查看hello可执行文件所依赖的动态链接文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[wyl@localhost readELF]$ ldd hello&#10;&#9;linux-gate.so.1 =&#62;  (0x00d23000)&#10;&#9;libc.so.6 =&#62; /lib/libc.so.6 (0x002a3000)&#10;&#9;/lib/ld-linux.so.2 (0x001be000)&#10;[wyl@localhost readELF]$</span><br></pre></td></tr></table></figure>
<p>ldd 所告诉您的是：该 ELF 映像依赖于 linux-gate.so（一个特殊的共享对象，它处理系统调用，它在文件系统中无关联文件）、GNU C 库（libc.so）以及 Linux 动态加载器（因为它里面有共享库依赖项）。</p>
<p>动态链接要解决的一个主要问题就是装载时在虚拟空间的位置？为了实现动态链接，首先会遇到的问题就是共享对象的地址冲突问题，因为你没有办法规定说哪个贡献文件必须在哪个地址。但是程序模块中的指令和数据中包含一些绝对地址的引用。</p>
<blockquote>
<p>装载时重定位</p>
</blockquote>
<p>为了能够使共享对象可以在任意地址装载，我们首先想到的方法就是静态链接中的重定位。这个想法的基本思路是，在链接时，对所有绝对地址的引用不做重定位，而是把这一步推迟到装载时在完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址进行重定位。假设函数foor 相对于代码段的起始地址是0x100，当模块被装载到0x10000000,那么我们就可以确定foor的地址为0x10000100。这个时候，系统遍历模块中的重定位表，把所有对foor的地址引用都重定位到0x10000100。这种情况常被称为装载时重定位（Load Time Relocation），在windows 中，这种装载时重定位又被称为基址重置（Rebasing）。</p>
<p>但是装载时重定位的方法并不适合用来解决上面的共享对象中所存在的问题。可以想象，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因此指令被重定位后对于每个进程来讲是不一样的。当然，动态链接库中的可修改数据部分对于不同的进程来说有多个副本，所以他们可以采用装载时重定位的方法。</p>
<blockquote>
<p>地址无关代码</p>
</blockquote>
<p>Linux 和 gcc 支持这种装载时重定位的方法。我们在产生共享对象时，使用了两个gcc的参数“-shared”和“-fPIC”。</p>
<p>装载时重定位可以解决模块中有绝对地址引用的方法之一，但是他有一个很大的缺点就是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的优势。一种好的解决方法是，把指令中那些需要修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是地址无关代码技术（PIC, Position-indenpendent Code）。</p>
<p>那么产生地址相关代码都有哪些类型呢？</p>
<ul>
<li>第一中是模块内部的函数调用，跳转等；</li>
<li>第二中是模块内部的数据访问，比如说模块中定义的全局变量，静态变量；</li>
<li>第三中模块外部的函数调用，跳转等；</li>
<li>第四种模块外部的数据访问，比如其他模块中定义的全局变量。 </li>
</ul>
<hr>
<p>测试用的源代码：<br><figure class="highlight c"><figcaption><span>test.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">	b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	bar();</span><br><span class="line">	ext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 编译命令： <code>gcc -shared -fPIC test.c -o test.so</code></p>
<p>使用<code>objdump -d test.so</code>查看反汇编的代码主要部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000545</span> &lt;__x86.<span class="keyword">get_pc_t</span>hunk.bx&gt;:</span><br><span class="line"> <span class="number">545</span>:	<span class="number">8</span>b <span class="number">1</span>c <span class="number">24</span>             	mov    (%esp),%ebx</span><br><span class="line"> <span class="number">548</span>:	c3                   	ret    </span><br><span class="line"> <span class="number">549</span>:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">54</span>a:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">54</span>b:	<span class="number">90</span>                   	nop</span><br><span class="line"></span><br><span class="line"><span class="number">0000054</span>c &lt;bar&gt;:</span><br><span class="line"> <span class="number">54</span>c:	<span class="number">55</span>                   	push   %ebp</span><br><span class="line"> <span class="number">54</span>d:	<span class="number">89</span> e5                	mov    %esp,%ebp</span><br><span class="line"> <span class="number">54f</span>:	e8 <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	call   <span class="number">594</span> &lt;__x86.<span class="keyword">get_pc_t</span>hunk.cx&gt;</span><br><span class="line"> <span class="number">554</span>:	<span class="number">81</span> c1 <span class="number">24</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span>    	add    $<span class="number">0x1224</span>,%ecx</span><br><span class="line"> <span class="number">55</span>a:	c7 <span class="number">81</span> <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> 	movl   $<span class="number">0x1</span>,<span class="number">0x28</span>(%ecx)</span><br><span class="line"> <span class="number">561</span>:	<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"> <span class="number">564</span>:	<span class="number">8</span>b <span class="number">81</span> f8 ff ff ff    	mov    -<span class="number">0x8</span>(%ecx),%eax</span><br><span class="line"> <span class="number">56</span>a:	c7 <span class="number">00</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	movl   $<span class="number">0x2</span>,(%eax)</span><br><span class="line"> <span class="number">570</span>:	<span class="number">5</span>d                   	pop    %ebp</span><br><span class="line"> <span class="number">571</span>:	c3                   	ret    </span><br><span class="line"></span><br><span class="line"><span class="number">00000572</span> &lt;foo&gt;:</span><br><span class="line"> <span class="number">572</span>:	<span class="number">55</span>                   	push   %ebp</span><br><span class="line"> <span class="number">573</span>:	<span class="number">89</span> e5                	mov    %esp,%ebp</span><br><span class="line"> <span class="number">575</span>:	<span class="number">53</span>                   	push   %ebx</span><br><span class="line"> <span class="number">576</span>:	<span class="number">83</span> ec <span class="number">04</span>             	sub    $<span class="number">0x4</span>,%esp</span><br><span class="line"> <span class="number">579</span>:	e8 c7 ff ff ff       	call   <span class="number">545</span> &lt;__x86.<span class="keyword">get_pc_t</span>hunk.bx&gt;</span><br><span class="line"> <span class="number">57</span>e:	<span class="number">81</span> c3 fa <span class="number">11</span> <span class="number">00</span> <span class="number">00</span>    	add    $<span class="number">0x11fa</span>,%ebx</span><br><span class="line"> <span class="number">584</span>:	e8 <span class="number">13</span> fe ff ff       	call   <span class="number">39</span>c &lt;bar@plt&gt;</span><br><span class="line"> <span class="number">589</span>:	e8 <span class="number">2</span>e fe ff ff       	call   <span class="number">3</span>bc &lt;ext@plt&gt;</span><br><span class="line"> <span class="number">58</span>e:	<span class="number">83</span> c4 <span class="number">04</span>             	add    $<span class="number">0x4</span>,%esp</span><br><span class="line"> <span class="number">591</span>:	<span class="number">5</span>b                   	pop    %ebx</span><br><span class="line"> <span class="number">592</span>:	<span class="number">5</span>d                   	pop    %ebp</span><br><span class="line"> <span class="number">593</span>:	c3                   	ret    </span><br><span class="line"></span><br><span class="line"><span class="number">00000594</span> &lt;__x86.<span class="keyword">get_pc_t</span>hunk.cx&gt;:</span><br><span class="line"> <span class="number">594</span>:	<span class="number">8</span>b <span class="number">0</span>c <span class="number">24</span>             	mov    (%esp),%ecx</span><br><span class="line"> <span class="number">597</span>:	c3                   	ret    </span><br><span class="line"> <span class="number">598</span>:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">599</span>:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">59</span>a:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">59</span>b:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">59</span>c:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">59</span>d:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">59</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line"> <span class="number">59f</span>:	<span class="number">90</span>                   	nop</span><br></pre></td></tr></table></figure>
<ol>
<li>类型一 模块内部的调用<br>这一种情况最简单，模块内部的调用。被调用的函数与调用者都处于一个模块，他们之间的位置是固定不变得。对于现代的系统，模块内部的跳转，函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令不需要重定位。<br>虽然看起来很容易解决，但是由于存在<strong>全局符号介入（Global Symbol Interposition）问题</strong>，还是不能简单的采用相对寻址。</li>
<li>类型二 模块内部数据访问<br>指令中不能包含对数据的直接寻址，那么唯一的办法就是相对寻址。我们知道，一个模块前面一般是若干个页的代码，后面紧跟着若干页的数据，数据和代码之间的相对位置是固定的。那么对数据的寻址只需要加上固定的偏移量就可以了。但是，现代的体系结构中，对数据的寻址没有相对于指令地址（PC）的寻址方式，所以ELF用了一个很巧妙地办法来得到当前的pc值，然后再加上一个偏移量就可以达到访问相应变量的目的了。<br>函数”__x86.get_pc_thunk.cx”，这个函数的作用是把返回地址的值放到ecx寄存器，即把call的下一条指令的地址放到ecx寄存器。<br>接着执行一条add指令和一条mov指令，可以看到变量a的地址是add指令地址（ecx）加上两个偏移量0x1224和ox28。加上ox1224是当前位置与数据段的偏移，而0x28为变量 a 在数据段的偏移量。如果这个模块被加载到0x10000000,那么变量a的实际地址将是0x10000000+0x554+0x1224+0x28。</li>
<li><p>类型三 模块间数据访问<br>模块间的数据访问时比较麻烦的，这些模块间的全局变量的地址是跟模块装载地址有关的。ELF的做法是在数据段里面建立一个指向这些变量的指针数组，也成为全局偏移表（Global Offset Table,GOT）,当代码需要引用该全局变量时，可以通过GOT中相应的项间接引用。<br>当指令访问b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块时会查找每个变量所在的地址，然后填充GOT中的各项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在装载时被修改，每个程序都可以有独立的副本。<br>首先确定GOT相对于当前指令的偏移，然后从GOT表中得到变量b的地址。<br><img src="/img/blog/got.png" alt=""><br>通过<code>objdump -R test.so</code>可以看到变量b的重定位信息。</p>
<p> [wyl@localhost Code]$ objdump -R test.so</p>
<p> test.so:     file format elf32-i386</p>
<p> DYNAMIC RELOCATION RECORDS<br> OFFSET   TYPE              VALUE<br> 00001794 R<em>386<em>RELATIVE    <em>ABS</em><br> 00001760 R_386_GLOB_DAT    __gmon_start</em></em><br> 00001764 R_386_GLOB_DAT    _Jv_RegisterClasses<br> 00001768 R_386_GLOB_DAT    _ITM_deregisterTMCloneTable<br> 0000176c R_386_GLOB_DAT    _ITM_registerTMCloneTable<br> 00001770 R_386_GLOB_DAT    b</p>
</li>
<li><p>类型四 模块间调用、跳转<br>我们可以采用类似上面类型三的方法，不过不同的是，GOT表中相应的项保存的是目标函数的地址。这种方法很简单，但是存在一些性能问题，实际上ELF采用了一种更加复杂和精巧的方法。</p>
</li>
</ol>
<h2 id="延迟绑定">延迟绑定</h2><p>我们知道，动态链接比静态链接慢的主要原因是，对于全局和静态的数据访问都要进行复杂的 GOT 定位，然后间接寻址；对于模块间的调用也要先定位GOT表。另一个原因是，动态链接工作在运行时，即程序开始执行时，动态链接器都要进行一次链接工作，动态链接器会寻找并装载所需要的共享对象，然后进行符号查找地址重定位等工作，这些工作也势必会减慢程序的启动速度。</p>
<p>在动态链接下，程序模块之间包含了大量的函数引用，所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位。不过可以想象，在一个程序的运行过程中，有可能很多函数在程序执行完时都不会被用到，比如一些错误处理函数或者用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费。所以ELF采用了一种叫做延迟绑定（Lazy Binding）的做法，基本思想就是当函数第一次被用到时才进行绑定（符号查找，重定位等）。这种做法可以大大加快程序的启动速度。</p>
<p>ELF使用PLT(Procedure Linkage Table)的方法实现。ELF 将 GOT 表拆分成两个表叫做“.got”和“.got.plt”。其中前者用来保存全局变量引用的地址，后者用来保存函数引用的地址，也就是说所有对外部函数的引用全部被分离出来放到了“.got.plt”中。<br>当我们调用某个外部模块的函数时，如果按照通常的做法应该是通过GOT中相应的项进行间接跳转。PLT为了实现延迟绑定，在这个过程中间又增加了一层间接跳转。调用函数并不直接通过GOT跳转，而是通过一个叫做PLT项的结构来进行跳转。每个外部函数在PLT中都有一个相应的项，比如bar()函数在PLT中的项叫做bar@plt。<br>逻辑上的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar@plt:&#10;jmp *(bar@GOT)&#10;push n&#10;push moduleID&#10;jump _dl_runtime_resolve</span><br></pre></td></tr></table></figure>
<p>第一条指令通过GOT间接跳转，bar@GOT表示GOT中保存bar()这个函数相应的项。如果链接器在初始化阶段已经初始化该项，并且将bar的地址填入到该项，那么这个跳转指令的结果就是我们所期望的，跳转到bar(),实现函数的正确调用。但是由于延迟绑定，链接器在初始化阶段并没有将bar的地址填入到该项，而是将上面代码中第二条指令“push n”的地址填入到bar@GOT中，这个步骤不需要查找任何符号，所以代价很低。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。第二条指令时将一个数字 n 压入堆栈，这个数字是bar这个符号在重定位表“.rel.plt”中的下标。接着又是一条push指令将模块的ID压入到堆栈，然后跳转到_dl_runtime_resolve。然后调用_dl_runtime_resolve完成符号解析和重定位工作。_dl_runtime_resolve进行一系列工作以后将bar的真正地址填入到bar@GOT中。</p>
<p>一旦bar()这个函数被解析完毕，当我们再次调用bar@plt时，第一条jmp指令就能后跳转到真正的bar()函数中，bar()函数返回的时候会根据堆栈里面保存的EIP直接返回到调用者，而不会再继续执行bar@plt中第二条以后的指令，那段代码只会在符号未被解析时执行一次。</p>
<p>上面描述的是基本原理。实现时，“.got.plt”还有一个特殊的地方就是它的前三项是有特殊意义的。含义如下：</p>
<ul>
<li>第一项保存的是“.dynamic”段的地址</li>
<li>第二项保存的是本模块的ID</li>
<li>第三项保存的是_dl_runtime_resolve()的地址。</li>
</ul>
<p>其中，第二项和第三项又动态链接器在装载共享模块的时候负责将它们初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000039</span>c &lt;bar@plt&gt;:</span><br><span class="line"> <span class="number">39</span>c:	ff a3 <span class="number">0</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	jmp    *<span class="number">0xc</span>(%ebx)</span><br><span class="line"> <span class="number">3</span>a2:	<span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	push   $<span class="number">0x0</span></span><br><span class="line"> <span class="number">3</span>a7:	e9 e0 ff ff ff       	jmp    <span class="number">38</span>c &lt;_init+<span class="number">0x30</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">000003</span>bc &lt;ext@plt&gt;:</span><br><span class="line"> <span class="number">3</span>bc:	ff a3 <span class="number">14</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	jmp    *<span class="number">0x14</span>(%ebx)</span><br><span class="line"> <span class="number">3</span>c2:	<span class="number">68</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	push   $<span class="number">0x10</span></span><br><span class="line"> <span class="number">3</span>c7:	e9 c0 ff ff ff       	jmp    <span class="number">38</span>c &lt;_init+<span class="number">0x30</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="运行过程">运行过程</h2><p>在动态链接情况下，操作系统还不能在装载完可执行文件之后就把控制权交给可执行文件的入口。因为我们知道可执行文件依赖很多共享文件，这个时候可执行文件里对于很多外部符号的引用还处于无效地址的状态。所以在映射完可执行文件之后，操作系统会先启动一个动态链接器（Dynamic Linker）。</p>
<p>动态链接器ld.so 实际也是一个共享对象。操作系统在加载完动态链接器后，就将控制权交给动态链接器的入口地址。然后动态链接器完成一系列自身的初始化操作，然后根据当前环境参数，开始对可执行文件进行链接工作。当所有动态链接工作完成之后，动态链接器会将控制权交到可执行文件的入口地址，程序开始正式执行。</p>
<p>动态链接器由ELF文件中的 .interp 段指出。</p>
<h2 id="参考">参考</h2><ul>
<li>程序员的自我修养</li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries/" target="_blank" rel="external">Linux 动态剖析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="动态链接">动态链接</h2><p>动态链接英文是Dynamic Linking，需要解决空间浪费和更新困难这两个问题。最简单的办法就是把程序的模块相互划分开来，形成独立的文件，而不再将他们静态的链接在一起。简单地讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行时才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接(Dynamic Linking)的基本思想。</p>
<p>动态链接还有一个特点，就是程序在运行时可以动态地选择加载各种程序模块，这个优点就是后来被人们用来制作程序的插件(plug-in)。</p>]]>
    
    </summary>
    
      <category term="linking" scheme="http://ylwhere.tk/tags/linking/"/>
    
      <category term="compiler" scheme="http://ylwhere.tk/categories/compiler/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux malloc 函数]]></title>
    <link href="http://ylwhere.tk/2015/05/24/linux-malloc-%E5%87%BD%E6%95%B0/"/>
    <id>http://ylwhere.tk/2015/05/24/linux-malloc-函数/</id>
    <published>2015-05-24T05:58:53.000Z</published>
    <updated>2015-05-31T13:38:46.008Z</updated>
    <content type="html"><![CDATA[<h2 id="进程堆">进程堆</h2><p>想找个时间，看下malloc是如何实现的。有一种做法是，把进程的内存管理交给操作系统内核去做，既然内核管理者进程的地址空间，那么如何它提供一个系统调用，可以让程序使用这个系统调用申请内存，不久可以么？但是实际上这样做的性能比较差，因为每次程序申请或者释放内存都要进行系统调用。我们知道系统调用的性能开销是很大的，当程序中对堆的操作比较繁琐时，这样做的结果是会严重影响程序的性能。比较好的做法是程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，而具体来讲，管理者堆空间分配的往往是程序的运行库。</p>
<a id="more"></a>
<p>运行库相当于是向操作系统“批发”了一块较大的堆空间，然后“零售”给程序员用。当全部“售完”或者程序有大量的内存需求时，再根据实际需求想操作系统“进货”。当然运行库在程序零售堆空间时，必须管理它批发来的堆空间，不能把同一块地址出售两次，导致地址冲突。于是运行库需要一个算法来管理堆空间，这个算法就堆的分配算法。</p>
<h2 id="Linux_进程堆空间">Linux 进程堆空间</h2><p>Linux 下的进程堆管理提供了两种堆空间的分配方式，即两个系统调用：</p>
<ul>
<li>一个是brk()系统调用</li>
<li>一个是mmap()系统调用。</li>
</ul>
<p>brk的声明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(brk, <span class="keyword">unsigned</span> <span class="keyword">long</span>, brk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rlim, retval;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> newbrk, oldbrk;</span><br><span class="line">	<span class="keyword">struct</span> mm_struct *mm = current-&gt;mm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_brk;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_COMPAT_BRK</span></span><br><span class="line">	min_brk = mm-&gt;end_code;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	min_brk = mm-&gt;start_brk;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (brk &lt; min_brk)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Check against rlimit here. If this check is done later after the test</span><br><span class="line">	 * of oldbrk with newbrk then it can escape the test and let the data</span><br><span class="line">	 * segment grow beyond its set limit the in case where the limit is</span><br><span class="line">	 * not page aligned -Ram Gupta</span><br><span class="line">	 */</span></span><br><span class="line">	rlim = current-&gt;signal-&gt;rlim[RLIMIT_DATA].rlim_cur;</span><br><span class="line">	<span class="keyword">if</span> (rlim &lt; RLIM_INFINITY &amp;&amp; (brk - mm-&gt;start_brk) +</span><br><span class="line">			(mm-&gt;end_data - mm-&gt;start_data) &gt; rlim)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	newbrk = PAGE_ALIGN(brk);</span><br><span class="line">	oldbrk = PAGE_ALIGN(mm-&gt;brk);</span><br><span class="line">	<span class="keyword">if</span> (oldbrk == newbrk)</span><br><span class="line">		<span class="keyword">goto</span> set_brk;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Always allow shrinking brk. */</span></span><br><span class="line">	<span class="keyword">if</span> (brk &lt;= mm-&gt;brk) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!do_munmap(mm, newbrk, oldbrk-newbrk))</span><br><span class="line">			<span class="keyword">goto</span> set_brk;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check against existing mmap mappings. */</span></span><br><span class="line">	<span class="keyword">if</span> (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ok, looks good - let it rip. */</span></span><br><span class="line">	<span class="keyword">if</span> (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">set_brk:</span><br><span class="line">	mm-&gt;brk = brk;</span><br><span class="line">out:</span><br><span class="line">	retval = mm-&gt;brk;</span><br><span class="line">	up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>brk 的实际作用就是设置进程数据段的结束地址，即它可以扩大或者缩小数据段。如果我们可将数据段的结束地址向高地址移动，那么扩大的那部分空间就可以被我们使用，把这块空间拿来作为堆空间是最常见的做法之一。</p>
<p>brk()在内核中对应的系统调用服务例程为SYSCALL_DEFINE1(brk, unsigned long, brk)，参数brk用来指定heap段新的结束地址，也就是重新指定mm_struct结构中的brk字段。</p>
<p>brk系统调用服务例程首先会确定heap段的起始地址min_brk，然后再检查资源的限制问题。接着，将新老heap地址分别按照页大小对齐，对齐后的地址分别存储与newbrk和okdbrk中。</p>
<p>brk()系统调用本身既可以缩小堆大小，又可以扩大堆大小。缩小堆这个功能是通过调用do_munmap()完成的。如果要扩大堆的大小，那么必须先通过find_vma_intersection()检查扩大以后的堆是否与已经存在的某个虚拟内存重合，如何重合则直接退出。否则，调用do_brk()进行接下来扩大堆的各种工作。</p>
<p>用户进程调用malloc()会使得内核调用brk系统调用服务例程，因为malloc总是动态的分配内存空间，因此该服务例程此时会进入第二条执行路径中，即扩大堆。do_brk()主要完成以下工作：</p>
<p>1.通过get_unmapped_area()在当前进程的地址空间中查找一个符合len大小的线性区间，并且该线性区间的必须在addr地址之后。如果找到了这个空闲的线性区间，则返回该区间的起始地址，否则返回错误代码-ENOMEM；</p>
<p>2.通过find_vma_prepare()在当前进程所有线性区组成的红黑树中依次遍历每个vma，以确定上一步找到的新区间之前的线性区对象的位置。如果addr位于某个现存的vma中，则调用do_munmap()删除这个线性区。如果删除成功则继续查找，否则返回错误代码。</p>
<p>3.目前已经找到了一个合适大小的空闲线性区，接下来通过vma_merge()去试着将当前的线性区与临近的线性区进行合并。如果合并成功，那么该函数将返回prev这个线性区的vm_area_struct结构指针，同时结束do_brk()。否则，继续分配新的线性区。</p>
<p>4.接下来通过kmem_cache_zalloc()在特定的slab高速缓存vm_area_cachep中为这个线性区分配vm_area_struct结构的描述符。</p>
<p>5.初始化vma结构中的各个字段。</p>
<p>6.更新mm_struct结构中的vm_total字段，它用来同级当前进程所拥有的vma数量。</p>
<p>7.如果当前vma设置了VM_LOCKED字段，那么通过mlock_vma_pages_range()立即为这个线性区分配物理页框。否则，do_brk()结束。</p>
<p>可以看到，do_brk()主要是为当前进程分配一个新的线性区，在没有设置VM_LOCKED标志的情况下，它不会立刻为该线性区分配物理页框，而是通过vma一直将分配物理内存的工作进行延迟，直至发生缺页异常。</p>
<hr>
<p>mmap()的作用是向操作系统申请一段虚拟地址空间，当然这块虚拟地址空间可以映射到某个文件（这也是这个系统调用的最初作用），当它不将地址空间映射到某个文件时，我们称为匿名空间，匿名空间就可以拿来作为堆分配。</p>
<p>关于mmap函数的详细介绍可以看后文的参考。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="preprocessor">#<span class="keyword">include</span> &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="keyword">void</span> *mmap(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span><br><span class="line">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, size_t length)</span></span>;</span><br><span class="line"></span><br><span class="line">prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起</span><br><span class="line">PROT_EXEC</span><br><span class="line">Pages may be executed.</span><br><span class="line">PROT_READ</span><br><span class="line">Pages may be read.</span><br><span class="line">PROT_WRITE</span><br><span class="line">Pages may be written.</span><br><span class="line">PROT_NONE</span><br><span class="line">Pages may not be accessed.</span><br></pre></td></tr></table></figure>
<p>flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体</p>
<p>MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</p>
<p>MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。</p>
<p>MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。</p>
<p>MAP_DENYWRITE //这个标志被忽略。</p>
<p>MAP_EXECUTABLE //同上</p>
<p>MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。</p>
<p>MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。</p>
<p>MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。</p>
<p>MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。</p>
<p>MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。</p>
<p>MAP_FILE //兼容标志，被忽略。  </p>
<p>MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。</p>
<p>MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。</p>
<p>MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</p>
<p>fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1。</p>
<p>offset：被映射对象内容的起点。<br>下面的do_mmap 函数是mmap函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> offset)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ret = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> ((offset + PAGE_ALIGN(len)) &lt; offset)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> (!(offset &amp; ~PAGE_MASK))</span><br><span class="line">		ret = do_mmap_pgoff(file, addr, len, prot, flag, offset &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存的虚拟页和物理页面的数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * This struct defines a memory VMM memory area. There is one of these</span><br><span class="line"> * per VM-area/task.  A VM area is any part of the process virtual memory</span><br><span class="line"> * space that has a special rule for the page-fault handlers (ie a shared</span><br><span class="line"> * library, the executable area etc).</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> vm_area_struct &#123;</span><br><span class="line">	<span class="keyword">struct</span> mm_struct * vm_mm;	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span><br><span class="line">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="keyword">struct</span> vm_area_struct *vm_next, *vm_prev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> rb_node vm_rb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * For areas with an address space and backing store,</span><br><span class="line">	 * linkage into the address_space-&gt;i_mmap prio tree, or</span><br><span class="line">	 * linkage to the list of like vmas hanging off its node, or</span><br><span class="line">	 * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="keyword">struct</span> list_head <span class="built_in">list</span>;</span><br><span class="line">			<span class="keyword">void</span> *parent;	<span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">			<span class="keyword">struct</span> vm_area_struct *head;</span><br><span class="line">		&#125; vm_set;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">struct</span> <span class="keyword">raw_prio_t</span>ree_node <span class="keyword">prio_t</span>ree_node;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span><br><span class="line">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span><br><span class="line">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span><br><span class="line">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head anon_vma_node;	<span class="comment">/* Serialized by anon_vma-&gt;lock */</span></span><br><span class="line">	<span class="keyword">struct</span> anon_vma *anon_vma;	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> vm_operations_struct *vm_ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span><br><span class="line">					   units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">	<span class="keyword">struct</span> file * vm_file;		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">vm_t</span>runcate_count;<span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifndef CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">struct</span> vm_region *vm_region;	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">struct</span> mempolicy *vm_policy;	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> mm_struct &#123;</span><br><span class="line">	<span class="keyword">struct</span> vm_area_struct * mmap;		<span class="comment">/* list of VMAs */</span></span><br><span class="line">	<span class="keyword">struct</span> rb_root mm_rb;</span><br><span class="line">	<span class="keyword">struct</span> vm_area_struct * mmap_cache;	<span class="comment">/* last find_vma result */</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line">	<span class="keyword">void</span> (*unmap_area) (<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;		<span class="comment">/* base of mmap area */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;		<span class="comment">/* size of task vm space */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cached_hole_size; 	<span class="comment">/* if non-zero, the largest hole below free_area_cache */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache;		<span class="comment">/* first hole of size cached_hole_size or larger */</span></span><br><span class="line">	<span class="keyword">pgd_t</span> * pgd;</span><br><span class="line">	<span class="keyword">atomic_t</span> mm_users;			<span class="comment">/* How many users with user space? */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> mm_count;			<span class="comment">/* How many references to "struct mm_struct" (users count as 1) */</span></span><br><span class="line">	<span class="keyword">int</span> map_count;				<span class="comment">/* number of VMAs */</span></span><br><span class="line">	<span class="keyword">struct</span> rw_semaphore mmap_sem;</span><br><span class="line">	<span class="keyword">spinlock_t</span> <span class="keyword">page_t</span>able_lock;		<span class="comment">/* Protects page tables and some counters */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> list_head mmlist;		<span class="comment">/* List of maybe swapped mm's.	These are globally strung</span><br><span class="line">						 * together off init_mm.mmlist, and are protected</span><br><span class="line">						 * by mmlist_lock</span><br><span class="line">						 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Special counters, in some configurations protected by the</span><br><span class="line">	 * page_table_lock, in other configurations by being atomic.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">mm_counter_t</span> _file_rss;</span><br><span class="line">	<span class="keyword">mm_counter_t</span> _anon_rss;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss;	<span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;	<span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> linux_binfmt *binfmt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">cpumask_t</span> cpu_vm_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">	<span class="keyword">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Swap token stuff */</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Last value of global fault stamp as seen by this process.</span><br><span class="line">	 * In other words, this value gives an indication of how long</span><br><span class="line">	 * it has been since this task got the token.</span><br><span class="line">	 * Look at mm/thrash.c</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> faultstamp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> token_priority;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> last_interval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> core_state *core_state; <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_AIO</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		ioctx_lock;</span><br><span class="line">	<span class="keyword">struct</span> hlist_head	ioctx_list;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MM_OWNER</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * "owner" points to a task that is regarded as the canonical</span><br><span class="line">	 * user/owner of this mm. All of the following must be true in</span><br><span class="line">	 * order for it to be changed:</span><br><span class="line">	 *</span><br><span class="line">	 * current == mm-&gt;owner</span><br><span class="line">	 * current-&gt;mm != mm</span><br><span class="line">	 * new_owner-&gt;mm == mm</span><br><span class="line">	 * new_owner-&gt;alloc_lock is held</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *owner;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_PROC_FS</span></span><br><span class="line">	<span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">	<span class="keyword">struct</span> file *exe_file;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_MMU_NOTIFIER</span></span><br><span class="line">	<span class="keyword">struct</span> mmu_notifier_mm *mmu_notifier_mm;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="堆分配算法">堆分配算法</h2><h3 id="1-空闲链表">1.空闲链表</h3><p>空闲链表的方法实际上就是把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个列表，直到找个合适大小的块将它拆分；当用户释放时将释放空间进行合并。</p>
<p>空闲链表是这样的一种结构，在堆里的每个空闲空间的开头有一个头（header）,头结构里记录了上一个（prev）和下一个（next）空闲块的地址，也就是说所有的空闲块行程了一个链表。</p>
<h3 id="2-位图">2.位图</h3><p>其核心思想就是将整个堆划分为大量的块（block）,每个块的大小相同。当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块成为已分配区域的头(head)，其余的成为已分配区域的主体(body)。我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三张状态，因此仅仅需要两位即可表示一个块，因此成为位图。</p>
<p><img src="/img/blog/bitmap.png" alt=""></p>
<p>这个堆分配了3片内存，分别有2/4/1个块，用虚线框表示。其对应的位图将是:</p>
<pre><code><span class="number">11 00 00 10</span> <span class="number">10 10 11 00</span> <span class="number">00 00 00 00</span> <span class="number">00 00 00 10</span> 11
</code></pre><p>其中11表示H(head), 10 表示主体B(Body), 00 表示空闲F(Free)</p>
<blockquote>
<p>实现方式的优点：</p>
</blockquote>
<ul>
<li>速度快：由于整个堆的空闲信息存储在一个数组内，因此访问该数组时，cache容易命中。</li>
<li>稳定性好：为了避免用户越界读写而破坏了数据，我们只需简单地备份一下位图即可。而且即使部分数据被破坏，也不会导致整个堆无法工作。</li>
<li>块不需要格外信息，易于管理。</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>分配内存的时候容易产生碎片</li>
<li>如果堆很大，或者设定的一个块很小，那么位图将很大，可能失去cache命中率高的优势，而且会浪费一定的空间。针对这种情况，可以使用多级位图。  </li>
</ul>
<h2 id="glibc_malloc_实现">glibc malloc 实现</h2><p>dlmalloc是目前一个十分流行的内存分配器，其由Doug Lea 从1987年开始编写，到目前为止，最新版本为2.8.3 ，由于其高效率等特点被广泛的使用和研究（很多linux系统等用的就是dlmalloc或其变形，比如ptmalloc ）。</p>
<blockquote>
<p>dlmalloc采用所谓的边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> malloc_chunk* fd;         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="keyword">struct</span> malloc_chunk* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们先来看看只考虑使用结构体malloc_chunk管理内存的情况，如下图所示：</p>
<p><img src="/img/blog/malloc_chunk.png" alt=""></p>
<p>可以有多个连续的被使用中chunk块，但是不会有多个连续的空闲chunk块，因为连续的多个空闲chunk块可以合并成一个大的空闲chunk块。<br>按照边界标记法，结构体malloc_chunk通过字段head和prev_foot将内存分割成很多块，从图1中①所示。字段head记录与本块相关的信息，这包括本chunk块大小，本块是否在使用中，前一chunk块是否在使用中。head一个字段就能存储这么多信息是因为dlmalloc在分割内存的时候总是以地址对齐（默认是8字节，可以自由设置，但是8字节是最小值并且设置的值必须是2为底的幂函数值，即是alignment = 2^n，n为整数且n&gt;=3）的方式来进行的，所以用head来存储本chunk块大小字节数的话，其末3bit位总是0，因此这三位可以用来存储其它信息，比如：<br>以第0位作为标志位，标记前一chunk块是否在使用中，为1表示使用，为0表示空闲。</p>
<p>我们来看看它们的各自相关判断代码：</p>
<pre><code><span class="hexcolor">#def</span>ine SIZE_T_ONE          ((size_t)<span class="number">1</span>)
<span class="hexcolor">#def</span>ine SIZE_T_TWO          ((size_t)<span class="number">2</span>)
<span class="hexcolor">#def</span>ine PINUSE_BIT          (SIZE_T_ONE)
<span class="hexcolor">#def</span>ine CINUSE_BIT          (SIZE_T_TWO)
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">cinuse</span><span class="params">(p)</span></span>           ((p)-&gt;head &amp; CINUSE_BIT)
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">pinuse</span><span class="params">(p)</span></span>           ((p)-&gt;head &amp; PINUSE_BIT)
</code></pre><p>prev_foot字段虽然在当前chunk块结构体内，记录的却是前一个邻接chunk块的信息（有特例存在，马上会讲到），这样做的好处就是我们通过本块chunk结构体就可以直接获取到前一chunk块的信息，从而方便做进一步的处理操作。相对的，当前chunk块的foot信息就存在于下一个邻接chunk块的结构体内。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">malloc_chunk details:</span><br><span class="line"></span><br><span class="line">(The following includes lightly edited explanations by Colin Plumb.)</span><br><span class="line"></span><br><span class="line">Chunks of memory are maintained using a `boundary tag' method as</span><br><span class="line">described in e.g., Knuth or Standish.  (See the paper by Paul</span><br><span class="line">Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span><br><span class="line">survey of such techniques.)  Sizes of free chunks are stored both</span><br><span class="line">in the front of each chunk and at the end.  This makes</span><br><span class="line">consolidating fragmented chunks into bigger chunks very fast.  The</span><br><span class="line">size fields also hold bits representing whether chunks are free or</span><br><span class="line">in use.</span><br><span class="line"></span><br><span class="line">An allocated chunk looks like this:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of previous chunk, if allocated            | |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             User data starts here...                          .</span><br><span class="line">    .                                                               .</span><br><span class="line">    .             (malloc_usable_size() bytes)                      .</span><br><span class="line">    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of chunk                                     |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Where "chunk" is the front of the chunk for the purpose of most of</span><br><span class="line">the malloc code, but "mem" is the pointer that is returned to the</span><br><span class="line">user.  "Nextchunk" is the beginning of the next contiguous chunk.</span><br><span class="line"></span><br><span class="line">Chunks always begin on even word boundaries, so the mem portion</span><br><span class="line">(which is returned to the user) is also on an even word boundary, and</span><br><span class="line">thus at least double-word aligned.</span><br><span class="line"></span><br><span class="line">Free chunks are stored in circular doubly-linked lists, and look like this:</span><br><span class="line"></span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of previous chunk                            |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:' |             Size of chunk, in bytes                         |P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Forward pointer to next chunk in list             |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Back pointer to previous chunk in list            |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Unused space (may be 0 bytes long)                .</span><br><span class="line">    .                                                               .</span><br><span class="line">    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:' |             Size of chunk, in bytes                           |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p>
<p>在深入理解操作系统那本书里有关于这个分配器算法的介绍，再次就不再详细说了。（其实我也不太懂。。囧。。）</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/jltxgcy/article/details/44150429" target="_blank" rel="external">brk() 函数</a></li>
<li><a href="http://edsionte.com/techblog/archives/4174" target="_blank" rel="external">brk() 函数解释</a></li>
<li><a href="http://blog.chinaunix.net/uid-26669729-id-3077015.html" target="_blank" rel="external">mmap() 函数详解</a></li>
<li><a href="http://blog.csdn.net/larryliuqing/article/details/7224672" target="_blank" rel="external">dlmalloc() 函数详解</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="进程堆">进程堆</h2><p>想找个时间，看下malloc是如何实现的。有一种做法是，把进程的内存管理交给操作系统内核去做，既然内核管理者进程的地址空间，那么如何它提供一个系统调用，可以让程序使用这个系统调用申请内存，不久可以么？但是实际上这样做的性能比较差，因为每次程序申请或者释放内存都要进行系统调用。我们知道系统调用的性能开销是很大的，当程序中对堆的操作比较繁琐时，这样做的结果是会严重影响程序的性能。比较好的做法是程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，而具体来讲，管理者堆空间分配的往往是程序的运行库。</p>]]>
    
    </summary>
    
      <category term="memory" scheme="http://ylwhere.tk/tags/memory/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux 栈和堆空间]]></title>
    <link href="http://ylwhere.tk/2015/05/23/linux-%E6%A0%88%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/"/>
    <id>http://ylwhere.tk/2015/05/23/linux-栈和堆空间/</id>
    <published>2015-05-23T03:21:14.000Z</published>
    <updated>2015-05-24T02:32:55.757Z</updated>
    <content type="html"><![CDATA[<h2 id="运行时栈">运行时栈</h2><p>程序的运行离不开栈空间和堆空间。栈中保存着程序运行的局部变量还有最重要的是，维持了函数调用的活动记录和关系。因为程序语言设计的允许递归调用，所以程序的局部变量必须存储在栈空间中，每一次函数调用都会有不同的活动记录。而函数执行完成后会回收当前的栈帧，所以无法通过函数返回值来访问回收后的局部变量，当然，<code>static</code> 变量除外。 因为编译器遇到<code>static</code> 变量时是按全局变量处理的，在符号表中有<code>static</code>变量的位置。只不过其访问权限只能在函数内。</p>
<a id="more"></a>
<h2 id="活动记录">活动记录</h2><p>活动记录又称为栈帧，一般保存如下几个方面的内容。</p>
<p><img src="/img/blog/stack_frame.png" alt=""></p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他的临时变量。</li>
<li>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li>
</ul>
<hr>
<p>函数调用的过程如下：</p>
<ul>
<li>把函数的参数压入栈中，或者通过寄存器传递参数，或者是内存的共享变量</li>
<li>把当前指令的下一条指令压入栈中。(call 指令)</li>
<li>跳转到具体函数执行。(设置eip的值为调用函数的入口地址)</li>
</ul>
<h2 id="栈大小">栈大小</h2><ol>
<li>栈默认是向下生长的，也就是栈底在搞地址，栈顶在底地址。如下图所示</li>
</ol>
<p><img src="/img/blog/stack_model.png" alt=""></p>
<ol>
<li>栈空间默认大小在我的机器上是10M。可以通过<code>ulimit -a</code> 来查看系统设置的资源。其中设置的栈空间默认大小为10M。但是我却不知道栈底到底是怎么设置和映射的，应该是<code>exec</code>函数在读取可执行文件后，把 elf 文件的数据段和代码段分别映射到对应的虚拟地址空间后，剩下的空间映射为进程的栈空间和堆空间。</li>
</ol>
<p><img src="/img/blog/stack_size.png" alt=""></p>
<ol>
<li>我写了一个程序来测试机器上的栈空间大小，其中有一段嵌入式汇编。基本想法是：利用函数执行前和执行后esp指针之差来估算栈的大小，基本也是10M大小。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt; </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;pthread.h&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> stack_begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> stack_end = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> stack_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入式汇编</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> read_esp(stack_addr) \ </span></span><br><span class="line">(&#123; \</span><br><span class="line">	__asm__ (\</span><br><span class="line">		<span class="string">"movl %%esp, %%eax; \</span><br><span class="line">		 movl %%eax, %0;"</span>	\</span><br><span class="line">		:<span class="string">"=r"</span>(stack_addr)); \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *test() </span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		read_esp(stack_begin);  <span class="comment">//第一次读取esp 的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	read_esp(stack_end);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"esp size = %d\n"</span>, stack_begin - stack_end);   <span class="comment">//栈自顶向下</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> buffer[<span class="number">1024</span>]; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"i=%d\n"</span>, i); </span><br><span class="line">	i++; </span><br><span class="line">	test(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_t</span> p; </span><br><span class="line">	read_esp(stack_begin);</span><br><span class="line">	pthread_create(&amp;p, NULL, &amp;test, NULL); </span><br><span class="line">	</span><br><span class="line">	sleep(<span class="number">100</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中栈空间大小可以通过<code>ulimit -s</code> 来设置大小。在此我就不测试了。<br><img src="/img/blog/stack_size_test.png" alt=""><br>通过程序的运行结果可以看出来，运行过程中出现的<code>segement fault</code> 就是栈溢出了。</p>
<blockquote>
<p>通过<code>cat proc/stack/maps</code> 查看进程的映射信息发现栈空间开始地址为<code>bf885000</code></p>
</blockquote>
<p><img src="/img/blog/stack_mem.PNG" alt=""></p>
<h2 id="函数返回值传递">函数返回值传递</h2><p>函数的参数一般是通过eax作为返回值，但是当函数参数大于4字节。对于5~8 字节的数据，默认是按<code>eax, edx</code> 联合返回的。但是一个结构体或者一个类对象，那么是如何处理呢? </p>
<h3 id="结构体">结构体</h3><p>测试的代码如下，为了方便，也给出了对应的AT&amp;T 的汇编代码。<br>首先声明了一个结构体，大小为100*4 = 400 个字节。 400 = 0x190 (16进制)<br>用 <code>objdump -d test.o</code> 可以看到程序对应的源代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">big_t</span>hing</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> buf[<span class="number">100</span>];</span><br><span class="line">&#125;<span class="keyword">big_t</span>hing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">big_t</span><span class="function">hing <span class="title">return_test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">big_t</span>hing b;</span><br><span class="line">	b.buf[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">big_t</span>hing n;</span><br><span class="line">	n = <span class="keyword">return_t</span>est();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> &lt;<span class="keyword">return_t</span>est&gt;:</span><br><span class="line">   <span class="number">0</span>:	<span class="number">55</span>                   	push   %ebp</span><br><span class="line">   <span class="number">1</span>:	<span class="number">89</span> e5                	mov    %esp,%ebp</span><br><span class="line">   <span class="number">3</span>:	<span class="number">57</span>                   	push   %edi</span><br><span class="line">   <span class="number">4</span>:	<span class="number">56</span>                   	push   %esi</span><br><span class="line">   <span class="number">5</span>:	<span class="number">53</span>                   	push   %ebx</span><br><span class="line">   <span class="number">6</span>:	<span class="number">81</span> ec <span class="number">90</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>    	sub    $<span class="number">0x190</span>,%esp       	<span class="comment">//为 b 分配空间</span></span><br><span class="line">   c:	c7 <span class="number">85</span> <span class="number">64</span> fe ff ff <span class="number">01</span> 	movl   $<span class="number">0x1</span>,-<span class="number">0x19c</span>(%ebp) 	<span class="comment">// b的起始地址</span></span><br><span class="line">  <span class="number">13</span>:	<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">16</span>:	<span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>             	mov    <span class="number">0x8</span>(%ebp),%eax  		<span class="comment">// eax = &amp;n;</span></span><br><span class="line">  <span class="number">19</span>:	<span class="number">89</span> c3                	mov    %eax,%ebx        	<span class="comment">// ebx = &amp;n;</span></span><br><span class="line">  <span class="number">1</span>b:	<span class="number">8</span>d <span class="number">85</span> <span class="number">64</span> fe ff ff    	lea    -<span class="number">0x19c</span>(%ebp),%eax	<span class="comment">// eax = &amp;b;</span></span><br><span class="line">  <span class="number">21</span>:	ba <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x64</span>,%edx			<span class="comment">// edx = 100;(10进制)</span></span><br><span class="line">  <span class="number">26</span>:	<span class="number">89</span> df                	mov    %ebx,%edi			<span class="comment">// edi = &amp;n;</span></span><br><span class="line">  <span class="number">28</span>:	<span class="number">89</span> c6                	mov    %eax,%esi 			<span class="comment">// esi = &amp;b</span></span><br><span class="line">  <span class="number">2</span>a:	<span class="number">89</span> d1                	mov    %edx,%ecx			<span class="comment">// ecx = 100;</span></span><br><span class="line">  <span class="number">2</span>c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi) <span class="comment">//复制</span></span><br><span class="line">  <span class="number">2</span>e:	<span class="number">8</span>b <span class="number">45</span> <span class="number">08</span>             	mov    <span class="number">0x8</span>(%ebp),%eax		<span class="comment">// eax = &amp;n</span></span><br><span class="line">  <span class="number">31</span>:	<span class="number">81</span> c4 <span class="number">90</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>    	add    $<span class="number">0x190</span>,%esp			<span class="comment">// 平衡栈空间</span></span><br><span class="line">  <span class="number">37</span>:	<span class="number">5</span>b                   	pop    %ebx</span><br><span class="line">  <span class="number">38</span>:	<span class="number">5</span>e                   	pop    %esi</span><br><span class="line">  <span class="number">39</span>:	<span class="number">5f</span>                   	pop    %edi</span><br><span class="line">  <span class="number">3</span>a:	<span class="number">5</span>d                   	pop    %ebp</span><br><span class="line">  <span class="number">3</span>b:	c2 <span class="number">04</span> <span class="number">00</span>             	ret    $<span class="number">0x4</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000003</span>e &lt;main&gt;:</span><br><span class="line">  <span class="number">3</span>e:	<span class="number">55</span>                   	push   %ebp</span><br><span class="line">  <span class="number">3f</span>:	<span class="number">89</span> e5                	mov    %esp,%ebp</span><br><span class="line">  <span class="number">41</span>:	<span class="number">81</span> ec <span class="number">90</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>    	sub    $<span class="number">0x190</span>,%esp     <span class="comment">//为 n 分配空间</span></span><br><span class="line">  <span class="number">47</span>:	<span class="number">8</span>d <span class="number">85</span> <span class="number">70</span> fe ff ff    	lea    -<span class="number">0x190</span>(%ebp),%eax <span class="comment">//eax = n的地址值</span></span><br><span class="line">  <span class="number">4</span>d:	<span class="number">50</span>                   	push   %eax              <span class="comment">//压栈</span></span><br><span class="line">  <span class="number">4</span>e:	e8 fc ff ff ff       	call   <span class="number">4f</span> &lt;main+<span class="number">0x11</span>&gt;    <span class="comment">//调用函数</span></span><br><span class="line">  <span class="number">53</span>:	c9                   	leave  </span><br><span class="line">  <span class="number">54</span>:	c3                   	ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我把程序的空间图画出来，如下图所示:  </p>
</blockquote>
<p><img src="/img/blog/stack_struct.png" alt=""></p>
<p>从上图可知，是先把 n的地址通过eax压入到堆栈中，作为 <code>return_test</code> 的参数。实际的函数可以理解为：<code>void return_test(big_thing *n)</code>。 可以推测编译器做了一定的优化，通过eax作为变量来传递结构体的地址，而<code>return_test</code>运行结束后，eax 仍然保存着变量n的地址。这也保证了main函数中栈空间eax值仍然不变。即eax是作为保护寄存器参数。</p>
<h3 id="类对象">类对象</h3><p>c++ 中的类对象与c中的对象有所不同，因为c++ 中可以定义赋值构造函数可以重载赋值操作符还有c++ 中的this 关键字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">big_t</span>hing</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">big_t</span>hing()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"big_thing construct"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">big_t</span>hing(<span class="keyword">const</span> <span class="keyword">big_t</span>hing &amp;rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"big_thing copy construct"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">big_t</span>hing&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">big_t</span>hing &amp;rhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"big_thing operator ="</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="keyword">big_t</span>hing()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"big_thing destruct"</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> buf[<span class="number">100</span>];</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">big_t</span><span class="function">hing <span class="title">return_test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">big_t</span>hing b;</span><br><span class="line">	b.buf[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">big_t</span>hing n;</span><br><span class="line">	n = <span class="keyword">return_t</span>est();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">big_t</span>hing construct</span><br><span class="line"><span class="keyword">big_t</span>hing construct</span><br><span class="line"><span class="keyword">big_t</span>hing <span class="keyword">operator</span> =</span><br><span class="line"><span class="keyword">big_t</span>hing destruct</span><br><span class="line"><span class="keyword">big_t</span>hing destruct</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>堆栈是程序运行过程中很重要的空间分配策略，但是当访问到不能访问的地址，或者栈空间不足时都会发生内存访问错误。要对错误进行分析，可以结合gdb的调试功能。<br>未完，下一篇谢谢关于malloc堆的分配问题。</p>
<h2 id="参考">参考</h2><ul>
<li>《程序员的自我修养》</li>
<li><a href="http://oss.org.cn/kernel-book/ch02/2.6.3.htm" target="_blank" rel="external">gcc 嵌入汇编</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="运行时栈">运行时栈</h2><p>程序的运行离不开栈空间和堆空间。栈中保存着程序运行的局部变量还有最重要的是，维持了函数调用的活动记录和关系。因为程序语言设计的允许递归调用，所以程序的局部变量必须存储在栈空间中，每一次函数调用都会有不同的活动记录。而函数执行完成后会回收当前的栈帧，所以无法通过函数返回值来访问回收后的局部变量，当然，<code>static</code> 变量除外。 因为编译器遇到<code>static</code> 变量时是按全局变量处理的，在符号表中有<code>static</code>变量的位置。只不过其访问权限只能在函数内。</p>]]>
    
    </summary>
    
      <category term="memory" scheme="http://ylwhere.tk/tags/memory/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大一下学期]]></title>
    <link href="http://ylwhere.tk/2015/05/22/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F/"/>
    <id>http://ylwhere.tk/2015/05/22/大一下学期/</id>
    <published>2015-05-22T14:17:45.000Z</published>
    <updated>2015-05-22T14:39:57.109Z</updated>
    <content type="html"><![CDATA[<h2 id="即逝的半学期">即逝的半学期</h2><p>前几天看到别人的博客，和我一样，也是研究生一年级的学生，看完感觉我整个人都安静下来。因为你突然发现有一个人，和你那么的像，也有一个姐姐。一个爱我们的父母。可是看到他这学期写的博客，感觉出了他的努力和认真。也感觉到了自己如此的浮躁。<br><a id="more"></a></p>
<h2 id="为什么写博客">为什么写博客</h2><p>看看自己写的博客，再看看别人的博客，我才知道我原来写博客是为了写博客，是为了满足自己的虚荣心，有些东西自己也是浮躁的一笔带过，其实有些东西，自己并不是有多么的了解，甚至是不懂，但是我还是急躁躁的想学习新的东西。不肯深挖，不啃把原理弄明吧。我知道这是我的一个弊端，希望以后可以好好更正，争取早日对自己有一个好的定位。</p>
<h2 id="玩的疯狂的一学期">玩的疯狂的一学期</h2><p>这学期是我玩的最high的一学期吧。抽时间去和良哥去桂林玩了一周，和小伙伴去植物园附近烧烤和实验室的小伙伴去骑行，以及去小伙伴家里吃饭。说实话，我感觉这学期真的好幸福，尽管没有看多少的书，写多少的代码，但是呵呵，疯了一个学期，玩的却是淋漓尽致。桂林的空气和水真的算是山清水秀，有时间，额，或许等有了女朋友吧。我决定再去看一看，看一看以前写过的那些记忆。这学期看的不错的一本<code>C++</code> 方面的书是： <code>《Effective C++》 和 《C++ 反编译》</code> 对C++ 有了更进一步的了解，但是还是没有多少实战经历。</p>
<h2 id="未来的计划">未来的计划</h2><p>是的，有计划总是最好不过的，这学期马上就结束了，师兄为了实习的事情在忙。而我们也要最为新的一批力量给项目，好吧，所谓的项目做贡献了。我不知道我还可以吐槽些那些所谓的项目任何细节。目前还是要先把这学期的考试好好完成的。</p>
<blockquote>
<p>计划</p>
</blockquote>
<ul>
<li>去所里完成项目的任务</li>
<li>每天晚上回实验室，坚持</li>
<li>尽量写有深度的博客，使自己静下来</li>
<li>多给爸爸打电话，虽然我们的话并不多</li>
</ul>
<hr>
<p> 日子一天的，每一天都会有不一样的心情。看到微博里有句话很好，“把努力当作一个习惯，而不是一时的冲动。”</p>
<p>加油，为了每一个爱你的人！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="即逝的半学期">即逝的半学期</h2><p>前几天看到别人的博客，和我一样，也是研究生一年级的学生，看完感觉我整个人都安静下来。因为你突然发现有一个人，和你那么的像，也有一个姐姐。一个爱我们的父母。可是看到他这学期写的博客，感觉出了他的努力和认真。也感觉到了自己如此的浮躁。<br>]]>
    
    </summary>
    
      <category term="心路札记" scheme="http://ylwhere.tk/categories/%E5%BF%83%E8%B7%AF%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tiny Web服务器]]></title>
    <link href="http://ylwhere.tk/2015/03/18/tiny-webfu-wu-qi/"/>
    <id>http://ylwhere.tk/2015/03/18/tiny-webfu-wu-qi/</id>
    <published>2015-03-18T09:09:28.000Z</published>
    <updated>2015-05-22T10:45:02.432Z</updated>
    <content type="html"><![CDATA[<p>初步了解了web服务器分为静态请求和动态请求。<br>cgi处理动态请求，并把结果返回给客户端</p>
<a id="more"></a>
<h3 id="表头文件">表头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;sys/stat.h&#62;    &#10;#include &#60;unistd.h&#62;</span><br></pre></td></tr></table></figure>
<p>定义函数:    int stat(const char <em>file_name, struct stat </em>buf);</p>
<p>函数说明:    通过文件名filename获取文件信息，并保存在buf所指的结构体stat中</p>
<p>返回值:     执行成功则返回0，失败返回-1，错误代码存于errno</p>
<p>先前所描述的st_mode 则定义了下列数种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IFMT   0170000    &#25991;&#20214;&#31867;&#22411;&#30340;&#20301;&#36974;&#32617;  &#10;S_IFSOCK 0140000    scoket  &#10;S_IFLNK 0120000     &#31526;&#21495;&#36830;&#25509;  &#10;S_IFREG 0100000     &#19968;&#33324;&#25991;&#20214;  &#10;S_IFBLK 0060000     &#21306;&#22359;&#35013;&#32622;  &#10;S_IFDIR 0040000     &#30446;&#24405;  &#10;S_IFCHR 0020000     &#23383;&#31526;&#35013;&#32622;  &#10;S_IFIFO 0010000     &#20808;&#36827;&#20808;&#20986;&#10;&#10;S_ISUID 04000     &#25991;&#20214;&#30340;(set user-id on execution)&#20301;  &#10;S_ISGID 02000     &#25991;&#20214;&#30340;(set group-id on execution)&#20301;  &#10;S_ISVTX 01000     &#25991;&#20214;&#30340;sticky&#20301;  &#10;&#10;S_IRUSR(S_IREAD) 00400     &#25991;&#20214;&#25152;&#26377;&#32773;&#20855;&#21487;&#35835;&#21462;&#26435;&#38480;  &#10;S_IWUSR(S_IWRITE)00200     &#25991;&#20214;&#25152;&#26377;&#32773;&#20855;&#21487;&#20889;&#20837;&#26435;&#38480;  &#10;S_IXUSR(S_IEXEC) 00100     &#25991;&#20214;&#25152;&#26377;&#32773;&#20855;&#21487;&#25191;&#34892;&#26435;&#38480;  &#10;&#10;S_IRGRP 00040             &#29992;&#25143;&#32452;&#20855;&#21487;&#35835;&#21462;&#26435;&#38480;  &#10;S_IWGRP 00020             &#29992;&#25143;&#32452;&#20855;&#21487;&#20889;&#20837;&#26435;&#38480;  &#10;S_IXGRP 00010             &#29992;&#25143;&#32452;&#20855;&#21487;&#25191;&#34892;&#26435;&#38480;  &#10;&#10;S_IROTH 00004             &#20854;&#20182;&#29992;&#25143;&#20855;&#21487;&#35835;&#21462;&#26435;&#38480;  &#10;S_IWOTH 00002             &#20854;&#20182;&#29992;&#25143;&#20855;&#21487;&#20889;&#20837;&#26435;&#38480;  &#10;S_IXOTH 00001             &#20854;&#20182;&#29992;&#25143;&#20855;&#21487;&#25191;&#34892;&#26435;&#38480;</span><br></pre></td></tr></table></figure>
<h3 id="web服务器程序">web服务器程序</h3><pre><code class="c">
<span class="comment">/* $begin tinymain */</span>
<span class="comment">/*
 * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the 
 *     GET method to serve static and dynamic content.
 */</span>

<span class="preprocessor">#<span class="keyword">include</span> "tiny.h"</span>

<span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">read_requesthdrs</span><span class="params">(rio_t *rp)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span> *uri, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">get_filetype</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *filetype)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *cause, <span class="keyword">char</span> *errnum, 
         <span class="keyword">char</span> *shortmsg, <span class="keyword">char</span> *longmsg)</span></span>;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> 
</span>{
    <span class="keyword">int</span> listenfd, connfd, port, clientlen;
    <span class="keyword">struct</span> sockaddr_in clientaddr;

    <span class="comment">/* Check command line args */</span>
    <span class="keyword">if</span> (argc != <span class="number">2</span>) {
    <span class="built_in">fprintf</span>(stderr, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);
    <span class="built_in">exit</span>(<span class="number">1</span>);
    }
    port = atoi(argv[<span class="number">1</span>]);

    listenfd = Open_listenfd(port);
    <span class="keyword">while</span> (<span class="number">1</span>) {
    clientlen = <span class="keyword">sizeof</span>(clientaddr);
    connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); <span class="comment">//line:netp:tiny:accept</span>
    doit(connfd);                                             <span class="comment">//line:netp:tiny:doit</span>
    Close(connfd);                                            <span class="comment">//line:netp:tiny:close</span>
    }
}
<span class="comment">/* $end tinymain */</span>

<span class="comment">/*
 * doit - handle one HTTP request/response transaction
 */</span>
<span class="comment">/* $begin doit */</span>
<span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> 
</span>{
    <span class="keyword">int</span> is_static;
    <span class="keyword">struct</span> stat sbuf;
    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    <span class="keyword">char</span> filename[MAXLINE], cgiargs[MAXLINE];
    <span class="keyword">rio_t</span> rio;

    <span class="comment">/* Read request line and headers */</span>
    Rio_readinitb(&amp;rio, fd);
    Rio_readlineb(&amp;rio, buf, MAXLINE);                   <span class="comment">//line:netp:doit:readrequest</span>
    <span class="built_in">sscanf</span>(buf, <span class="string">"%s %s %s"</span>, method, uri, version);       <span class="comment">//line:netp:doit:parserequest</span>
    <span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>)) {                     <span class="comment">//line:netp:doit:beginrequesterr</span>
       clienterror(fd, method, <span class="string">"501"</span>, <span class="string">"Not Implemented"</span>,
                <span class="string">"Tiny does not implement this method"</span>);
        <span class="keyword">return</span>;
    }                                                    <span class="comment">//line:netp:doit:endrequesterr</span>
    read_requesthdrs(&amp;rio);                              <span class="comment">//line:netp:doit:readrequesthdrs</span>

    <span class="comment">/* Parse URI from GET request */</span>
    is_static = parse_uri(uri, filename, cgiargs);       <span class="comment">//line:netp:doit:staticcheck</span>
    <span class="keyword">if</span> (stat(filename, &amp;sbuf) &lt; <span class="number">0</span>) {                     <span class="comment">//line:netp:doit:beginnotfound</span>
    clienterror(fd, filename, <span class="string">"404"</span>, <span class="string">"Not found"</span>,
            <span class="string">"Tiny couldn't find this file"</span>);
    <span class="keyword">return</span>;
    }                                                    <span class="comment">//line:netp:doit:endnotfound</span>

    <span class="keyword">if</span> (is_static) { <span class="comment">/* Serve static content */</span>          
    <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode)) { <span class="comment">//line:netp:doit:readable</span>
        clienterror(fd, filename, <span class="string">"403"</span>, <span class="string">"Forbidden"</span>,
            <span class="string">"Tiny couldn't read the file"</span>);
        <span class="keyword">return</span>;
    }
    serve_static(fd, filename, sbuf.st_size);        <span class="comment">//line:netp:doit:servestatic</span>
    }
    <span class="keyword">else</span> { <span class="comment">/* Serve dynamic content */</span>
    <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode)) { <span class="comment">//line:netp:doit:executable</span>
        clienterror(fd, filename, <span class="string">"403"</span>, <span class="string">"Forbidden"</span>,
            <span class="string">"Tiny couldn't run the CGI program"</span>);
        <span class="keyword">return</span>;
    }
    serve_dynamic(fd, filename, cgiargs);            <span class="comment">//line:netp:doit:servedynamic</span>
    }
}
<span class="comment">/* $end doit */</span>

<span class="comment">/*
 * read_requesthdrs - read and parse HTTP request headers
 */</span>
<span class="comment">/* $begin read_requesthdrs */</span>
<span class="function"><span class="keyword">void</span> <span class="title">read_requesthdrs</span><span class="params">(rio_t *rp)</span> 
</span>{
    <span class="keyword">char</span> buf[MAXLINE];

    Rio_readlineb(rp, buf, MAXLINE);
    <span class="keyword">while</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"\r\n"</span>)) {          <span class="comment">//line:netp:readhdrs:checkterm</span>
    Rio_readlineb(rp, buf, MAXLINE);
    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);
    }
    <span class="keyword">return</span>;
}
<span class="comment">/* $end read_requesthdrs */</span>

<span class="comment">/*
 * parse_uri - parse URI into filename and CGI args
 *             return 0 if dynamic content, 1 if static
 */</span>
<span class="comment">/* $begin parse_uri */</span>
<span class="function"><span class="keyword">int</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span> *uri, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span> 
</span>{
    <span class="keyword">char</span> *ptr;

    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(uri, <span class="string">"cgi-bin"</span>)) {  <span class="comment">/* Static content */</span> <span class="comment">//line:netp:parseuri:isstatic</span>
    <span class="built_in">strcpy</span>(cgiargs, <span class="string">""</span>);                             <span class="comment">//line:netp:parseuri:clearcgi</span>
    <span class="built_in">strcpy</span>(filename, <span class="string">"."</span>);                           <span class="comment">//line:netp:parseuri:beginconvert1</span>
    <span class="built_in">strcat</span>(filename, uri);                           <span class="comment">//line:netp:parseuri:endconvert1</span>
    <span class="keyword">if</span> (uri[<span class="built_in">strlen</span>(uri)-<span class="number">1</span>] == <span class="string">'/'</span>)                   <span class="comment">//line:netp:parseuri:slashcheck</span>
        <span class="built_in">strcat</span>(filename, <span class="string">"index.html"</span>);               <span class="comment">//line:netp:parseuri:appenddefault</span>
    <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="keyword">else</span> {  <span class="comment">/* Dynamic content */</span>                        <span class="comment">//line:netp:parseuri:isdynamic</span>
    ptr = index(uri, <span class="string">'?'</span>);                           <span class="comment">//line:netp:parseuri:beginextract</span>
    <span class="keyword">if</span> (ptr) {
        <span class="built_in">strcpy</span>(cgiargs, ptr+<span class="number">1</span>);
        *ptr = <span class="string">'\0'</span>;
    }
    <span class="keyword">else</span> 
        <span class="built_in">strcpy</span>(cgiargs, <span class="string">""</span>);                         <span class="comment">//line:netp:parseuri:endextract</span>
    <span class="built_in">strcpy</span>(filename, <span class="string">"."</span>);                           <span class="comment">//line:netp:parseuri:beginconvert2</span>
    <span class="built_in">strcat</span>(filename, uri);                           <span class="comment">//line:netp:parseuri:endconvert2</span>
    <span class="keyword">return</span> <span class="number">0</span>;
    }
}
<span class="comment">/* $end parse_uri */</span>

<span class="comment">/*
 * serve_static - copy a file back to the client 
 */</span>
<span class="comment">/* $begin serve_static */</span>
<span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span> 
</span>{
    <span class="keyword">int</span> srcfd;
    <span class="keyword">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];

    <span class="comment">/* Send response headers to client */</span>
    get_filetype(filename, filetype);       <span class="comment">//line:netp:servestatic:getfiletype</span>
    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>);    <span class="comment">//line:netp:servestatic:beginserve</span>
    <span class="built_in">sprintf</span>(buf, <span class="string">"%sServer: Tiny Web Server\r\n"</span>, buf);
    <span class="built_in">sprintf</span>(buf, <span class="string">"%sContent-length: %d\r\n"</span>, buf, filesize);
    <span class="built_in">sprintf</span>(buf, <span class="string">"%sContent-type: %s\r\n\r\n"</span>, buf, filetype);
    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));       <span class="comment">//line:netp:servestatic:endserve</span>

    <span class="comment">/* Send response body to client */</span>
    srcfd = Open(filename, O_RDONLY, <span class="number">0</span>);    <span class="comment">//line:netp:servestatic:open</span>
    srcp = Mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>);<span class="comment">//line:netp:servestatic:mmap</span>
    Close(srcfd);                           <span class="comment">//line:netp:servestatic:close</span>
    Rio_writen(fd, srcp, filesize);         <span class="comment">//line:netp:servestatic:write</span>
    Munmap(srcp, filesize);                 <span class="comment">//line:netp:servestatic:munmap</span>
}

<span class="comment">/*
 * get_filetype - derive file type from file name
 */</span>
<span class="function"><span class="keyword">void</span> <span class="title">get_filetype</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *filetype)</span> 
</span>{
    <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">".html"</span>))
    <span class="built_in">strcpy</span>(filetype, <span class="string">"text/html"</span>);
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">".gif"</span>))
    <span class="built_in">strcpy</span>(filetype, <span class="string">"image/gif"</span>);
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">".jpg"</span>))
    <span class="built_in">strcpy</span>(filetype, <span class="string">"image/jpeg"</span>);
    <span class="keyword">else</span>
    <span class="built_in">strcpy</span>(filetype, <span class="string">"text/plain"</span>);
}  
<span class="comment">/* $end serve_static */</span>

<span class="comment">/*
 * serve_dynamic - run a CGI program on behalf of the client
 */</span>
<span class="comment">/* $begin serve_dynamic */</span>
<span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span> 
</span>{
    <span class="keyword">char</span> buf[MAXLINE], *emptylist[] = { NULL };

    <span class="comment">/* Return first part of HTTP response */</span>
    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 200 OK\r\n"</span>); 
    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));
    <span class="built_in">sprintf</span>(buf, <span class="string">"Server: Tiny Web Server\r\n"</span>);
    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));

    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) { <span class="comment">/* child */</span> <span class="comment">//line:netp:servedynamic:fork</span>
    <span class="comment">/* Real server would set all CGI vars here */</span>
    setenv(<span class="string">"QUERY_STRING"</span>, cgiargs, <span class="number">1</span>); <span class="comment">//line:netp:servedynamic:setenv</span>
    Dup2(fd, STDOUT_FILENO);         <span class="comment">/* Redirect stdout to client */</span> <span class="comment">//line:netp:servedynamic:dup2</span>
    Execve(filename, emptylist, environ); <span class="comment">/* Run CGI program */</span> <span class="comment">//line:netp:servedynamic:execve</span>
    }
    Wait(NULL); <span class="comment">/* Parent waits for and reaps child */</span> <span class="comment">//line:netp:servedynamic:wait</span>
}
<span class="comment">/* $end serve_dynamic */</span>

<span class="comment">/*
 * clienterror - returns an error message to the client
 */</span>
<span class="comment">/* $begin clienterror */</span>
<span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *cause, <span class="keyword">char</span> *errnum, 
         <span class="keyword">char</span> *shortmsg, <span class="keyword">char</span> *longmsg)</span> 
</span>{
    <span class="keyword">char</span> buf[MAXLINE], body[MAXBUF];

    <span class="comment">/* Build the HTTP response body */</span>
    <span class="built_in">sprintf</span>(body, <span class="string">"&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;"</span>);
    <span class="built_in">sprintf</span>(body, <span class="string">"%s&lt;body bgcolor="</span><span class="string">"ffffff"</span><span class="string">"&gt;\r\n"</span>, body);
    <span class="built_in">sprintf</span>(body, <span class="string">"%s%s: %s\r\n"</span>, body, errnum, shortmsg);
    <span class="built_in">sprintf</span>(body, <span class="string">"%s&lt;p&gt;%s: %s\r\n"</span>, body, longmsg, cause);
    <span class="built_in">sprintf</span>(body, <span class="string">"%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n"</span>, body);

    <span class="comment">/* Print the HTTP response */</span>
    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 %s %s\r\n"</span>, errnum, shortmsg);
    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));
    <span class="built_in">sprintf</span>(buf, <span class="string">"Content-type: text/html\r\n"</span>);
    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));
    <span class="built_in">sprintf</span>(buf, <span class="string">"Content-length: %d\r\n\r\n"</span>, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(body));
    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));
    Rio_writen(fd, body, <span class="built_in">strlen</span>(body));
}
<span class="comment">/* $end clienterror */</span>
</code></pre>
<h3 id="运行结果">运行结果</h3><ul>
<li>编译好后可以使用fixfox访问 <a href="locahost:post/index.html" target="_blank" rel="external">locahost:post/index.html</a></li>
</ul>
<h3 id="附录">附录</h3><p>github 链接：<a href="https://github.com/ylwdream/TinyWeb" target="_blank" rel="external">https://github.com/ylwdream/TinyWeb</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>初步了解了web服务器分为静态请求和动态请求。<br>cgi处理动态请求，并把结果返回给客户端</p>]]>
    
    </summary>
    
      <category term="socket" scheme="http://ylwhere.tk/tags/socket/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[echo 简单的socket程序]]></title>
    <link href="http://ylwhere.tk/2015/03/18/echo-jian-dan-de-socketcheng-xu/"/>
    <id>http://ylwhere.tk/2015/03/18/echo-jian-dan-de-socketcheng-xu/</id>
    <published>2015-03-18T05:23:48.000Z</published>
    <updated>2015-05-22T11:09:56.093Z</updated>
    <content type="html"><![CDATA[<p>看到深入理解计算机系统，socket一张，进而对web服务器有了进一步的认识，但是这里却没有提到关于信号，中断等更多的知识。</p>
<p>要学习网络编程，tcp/ip详解，和stevens的unix 网络编程是必须要看的。</p>
<p>下面是从数据结构到函数的一个介绍。觉得实际写的时候最好有个.thm的帮助文档最好了。<br>要不那么多函数和参数很容易记错的。而且里面有大量的强制类型转换。</p>
<a id="more"></a>
<h2 id="通信过程">通信过程</h2><p>首先客户端和主机通信时建立在socket上的高级i/o操作。<br>而这个通信线路由唯一的client ip：port和serverip:port确定。</p>
<p>下面这个图真的十分重要。</p>
<img src="/img/blog-img/client_server.png">
<p>下面的两个定义的结构体其实是一样的东西，都是16个字节，只是不同的函数要求传递的参数不同，tcp/io遗留下来的诟病。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//ip address</span></span><br><span class="line"><span class="keyword">struct</span> in_addr</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> sockaddr</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;</span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family; <span class="comment">//总是AF_INT</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;</span><br><span class="line">	<span class="keyword">struct</span> in_addr sin_addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>]l <span class="comment">//为了对齐要求</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>INADDR_ANY就是指定地址为0.0.0.0的地址，这个地址事实上表示不确定地址，或“所有地址”、“任意地址”。</li>
<li>一般来说，在各个系统中均定义成为0值。</li>
</ul>
</blockquote>
<p>在linux下的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/netinet/in.h&#10;/* Address to accept any incoming messages. */&#10;#define INADDR_ANY ((in_addr_t) 0x00000000)</span><br></pre></td></tr></table></figure>
<p>定义好的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "tiny.h"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">int</span> port)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">struct</span> hostent *hp;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in serveraddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AF_INT 表示的因特网协议，SOCK_STREAM 表示这个套接字是因特网的一个端点</span></span><br><span class="line">    <span class="comment">// 返回的clientfd是部分打开的，还不能直接对套接字读写</span></span><br><span class="line">    <span class="keyword">if</span>((clientfd = socket(AF_INT, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//创建套接字失败</span></span><br><span class="line">    <span class="keyword">if</span>((hp = gethostbyname(hostname)) == NULL)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span>; <span class="comment">//DNS错误</span></span><br><span class="line"></span><br><span class="line">    bzero((<span class="keyword">char</span>*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    serveraddr.sin_family = AF_INT;</span><br><span class="line">    <span class="comment">//成员选择的优先级高于类型转换</span></span><br><span class="line">    <span class="comment">//设置服务器地址，已经是大端格式</span></span><br><span class="line">    bcopy((<span class="keyword">char</span>*)hp-&gt;h_addr_list[<span class="number">0</span>], (<span class="keyword">char</span>*)serveraddr.sin_addr.s_addr, hp-&gt;h_length);</span><br><span class="line">    serveraddr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(clientfd, (SA *)&amp;serveraddr, <span class="keyword">sizeof</span>(SA)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">3</span>; <span class="comment">//链接失败</span></span><br><span class="line">    <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">int</span> port)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> listenfd, optval = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in serveraddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((listenfd = sock(AF_INT, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//创建socket失败</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 能够使两个套接字和一个地址绑定，SO_RESUMEADDR */</span></span><br><span class="line">	<span class="keyword">if</span>(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,</span><br><span class="line">				  (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;optval, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	bzero((<span class="keyword">char</span>*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">	serveraddr.sin_family = AF_INT;</span><br><span class="line">	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">/* 表示服务器任意ip地址都可以 */</span></span><br><span class="line">	serveraddr.sin_port = htons(port);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(bind(listenfd, (SA *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">2</span>; <span class="comment">// bind函数错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(listen(listenfd, LISTENQ) &lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		errno = -<span class="number">3</span>;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">"error: %d, listen error\n"</span>, errno);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端程序">客户端程序</h2><blockquote>
<ul>
<li>下面是对应的客户端程序。</li>
</ul>
</blockquote>
<figure class="highlight c"><figcaption><span>echo_client.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "tiny.h"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clientfd, port;</span><br><span class="line">	<span class="keyword">char</span> *host, buf[MAXLINE];</span><br><span class="line">	<span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">"usage: %s &lt;host&gt; &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host = argv[<span class="number">1</span>];</span><br><span class="line">	port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	clientfd = Open_clientfd(host, port);</span><br><span class="line">	Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(Fgets(buf, MAXLINE, stdin) != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">		Fputs(buf, stdout);</span><br><span class="line">	&#125;</span><br><span class="line">	close(clientfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务器程序">服务器程序</h2><figure class="highlight c"><figcaption><span>echo_server.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "tiny.h"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lisenfd, connfd, port, clientlen;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in clientaddr;</span><br><span class="line">	<span class="keyword">struct</span> hostent *hp; <span class="comment">/* dns条目 */</span></span><br><span class="line">	<span class="keyword">char</span> *haddrp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(stderr, <span class="string">"usage: %s  &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	lisenfd = Open_listenfd(port);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">		connfd = accept(lisenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">		hp = gethostbyaddr((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;clientaddr.sin_addr.s_addr,</span><br><span class="line">							<span class="keyword">sizeof</span>(clientaddr.sin_addr.s_addr), AF_INET);</span><br><span class="line">		haddrp = inet_ntoa(clientaddr.sin_addr);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"server connected to %s (%s) \n"</span>, hp-&gt;h_name, haddrp);</span><br><span class="line"></span><br><span class="line">		echo(connfd);</span><br><span class="line">		close(connfd);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> n;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">	Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"server received %d bytes\n"</span>, n);</span><br><span class="line">		Rio_writen(connfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>看到深入理解计算机系统，socket一张，进而对web服务器有了进一步的认识，但是这里却没有提到关于信号，中断等更多的知识。</p>
<p>要学习网络编程，tcp/ip详解，和stevens的unix 网络编程是必须要看的。</p>
<p>下面是从数据结构到函数的一个介绍。觉得实际写的时候最好有个.thm的帮助文档最好了。<br>要不那么多函数和参数很容易记错的。而且里面有大量的强制类型转换。</p>]]>
    
    </summary>
    
      <category term="socket" scheme="http://ylwhere.tk/tags/socket/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ linux 下文件的元数据]]></title>
    <link href="http://ylwhere.tk/2015/03/17/linux-xia-wen-jian-de-yuan-shu-ju/"/>
    <id>http://ylwhere.tk/2015/03/17/linux-xia-wen-jian-de-yuan-shu-ju/</id>
    <published>2015-03-17T03:12:11.000Z</published>
    <updated>2015-05-22T11:17:15.538Z</updated>
    <content type="html"><![CDATA[<p>文件的元数据也就是记录文件系统的数据字典。<br>操作系统根据文件的元数据来解析文件，文件的元数据一般存储在文件的开头。</p>
<a id="more"></a>
<p>应用程序能够通过调用<code>stat</code>和<code>fstat</code>函数，检索关于文件的信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="preprocessor">#inlcude &lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> stat &#123;</span><br><span class="line">	<span class="keyword">dev_t</span>         st_dev;       <span class="comment">//文件的设备编号</span></span><br><span class="line">	<span class="keyword">ino_t</span>         st_ino;       <span class="comment">//节点</span></span><br><span class="line">	<span class="keyword">mode_t</span>        st_mode;      <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line">	<span class="keyword">nlink_t</span>       st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">	<span class="keyword">uid_t</span>         st_uid;       <span class="comment">//用户ID</span></span><br><span class="line">	<span class="keyword">gid_t</span>         st_gid;       <span class="comment">//组ID</span></span><br><span class="line">	<span class="keyword">dev_t</span>         st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">	<span class="keyword">off_t</span>         st_size;      <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;    <span class="comment">//块数</span></span><br><span class="line">	<span class="keyword">time_t</span>        st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line">	<span class="keyword">time_t</span>        st_mtime;     <span class="comment">//最后一次修改时间</span></span><br><span class="line">	<span class="keyword">time_t</span>        st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="&gt;*测试程序如下：">&gt;*测试程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * =====================================================================================</span><br><span class="line"> *</span><br><span class="line"> *       Filename:  statcheck.c</span><br><span class="line"> *</span><br><span class="line"> *    Description:  读取文件的元数据</span><br><span class="line"> *</span><br><span class="line"> *        Version:  1.0</span><br><span class="line"> *        Created:  03/16/2015 07:13:46 PM</span><br><span class="line"> *       Revision:  none</span><br><span class="line"> *       Compiler:  gcc</span><br><span class="line"> *</span><br><span class="line"> *         Author:  WYL (502), ylwzzu@gmail.com</span><br><span class="line"> *   Organization:  </span><br><span class="line"> *</span><br><span class="line"> * =====================================================================================</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "vm/csapp.h"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> stat st;</span><br><span class="line">	<span class="keyword">char</span> *type, *readok;</span><br><span class="line">	stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line">	<span class="keyword">if</span>(S_ISREG(st.st_mode))</span><br><span class="line">		type = <span class="string">"regular"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(st.st_mode))</span><br><span class="line">		type = <span class="string">"directory"</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		type = <span class="string">"other"</span>;</span><br><span class="line">	<span class="keyword">if</span>((st.st_mode &amp; S_IRUSR))</span><br><span class="line">		readok = <span class="string">"yes"</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		readok = <span class="string">"no"</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"filename %s "</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"type: %s, read: %s\n"</span>, type, readok);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"size %d blocksize %d alloc blocks %d \n"</span>, st.st_size, st.st_blksize, st.st_blocks);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有存储器的影射机制，使得进程可以通信。</p>
<ul>
<li>附录：<br><a href="https://code.google.com/p/memcached/wiki/ReleaseNotes1410" target="_blank" rel="external">memcached</a> 有空要读下源代码</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>文件的元数据也就是记录文件系统的数据字典。<br>操作系统根据文件的元数据来解析文件，文件的元数据一般存储在文件的开头。</p>]]>
    
    </summary>
    
      <category term="io" scheme="http://ylwhere.tk/tags/io/"/>
    
      <category term="memory" scheme="http://ylwhere.tk/tags/memory/"/>
    
      <category term="linux" scheme="http://ylwhere.tk/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FOX矩阵算法MPI编程实现]]></title>
    <link href="http://ylwhere.tk/2014/12/16/foxju-zhen-suan-fa-mpibian-cheng-shi-xian/"/>
    <id>http://ylwhere.tk/2014/12/16/foxju-zhen-suan-fa-mpibian-cheng-shi-xian/</id>
    <published>2014-12-15T16:23:20.000Z</published>
    <updated>2015-05-24T07:44:11.039Z</updated>
    <content type="html"><![CDATA[<p>Fox算法同样通过循环移位的办法来达到节省存储空间的目的。</p>
<a id="more"></a>
<p>设处理器个数p=q2，则算法的要点如下：</p>
<ol>
<li>所选中的对角线Aii向所在行的q个处理器进行一对多广播；</li>
<li>各处理器将自己所拥有的A和B的子块进行矩阵相乘运算；</li>
<li>B矩阵的块向上循环移动一位，从下面接受一个新的B矩阵块；</li>
<li>选择A的一个矩阵块作为广播源，选择方法：如果Aij是上次的广播源，则本次的广播源是Ai,(j+1)%q。其中’%’表示取模运算。转步骤2。</li>
</ol>
<p>附链接：<br><a href="http://202.197.191.206:8080/06/text/ch06/se03/6_3_4_3.htm#" target="_blank" rel="external">http://202.197.191.206:8080/06/text/ch06/se03/6_3_4_3.htm#</a></p>
<blockquote>
<ul>
<li>程序运行 mpirun -n proncs fox</li>
<li>其中n必须是平方数，例如：4、8、16</li>
</ul>
</blockquote>
<figure class="highlight c"><figcaption><span>FOX_MPI.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wyl </span></span><br><span class="line"><span class="comment">// c[n][n] = a[n][n]*b[n][n]</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mpi.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;malloc.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> a(i, j) a[i*stock + j]</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> b(i, j) b[i*stock + j]</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> c(i, j) c[i*stock + j]</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> A(i, j) A[i*Len + j]</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> B(i, j) B[i*Len + j]</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> C(i, j) C[i*Len + j]</span></span><br><span class="line"><span class="comment">//令进程数为Len</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myrank, numprocs;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line"><span class="keyword">int</span> send_i, send_j;      <span class="comment">//广播的块号</span></span><br><span class="line"><span class="keyword">int</span> send_m, recv_m;         <span class="comment">//广播的线程号 </span></span><br><span class="line">MPI_Status status;</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line"><span class="keyword">int</span> *A, *B, *C;</span><br><span class="line"><span class="keyword">int</span> *buf; <span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">int</span> stock, sqrt_p; <span class="comment">//每块大小和处理器个数的根号值 </span></span><br><span class="line">MPI_Datatype colum_data; <span class="comment">//每个块的大小stock*stock </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clm</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> stock)</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;stock; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;stock; ++j)</span><br><span class="line">	  &#123;</span><br><span class="line">	      <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;stock; k++)</span><br><span class="line">	      c(i,j) += a(i,k) * b(k,j);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_data</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B, <span class="keyword">int</span> Len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;Len; i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;Len; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		A[i*Len+j] = rand() % <span class="number">100</span>;</span><br><span class="line">		B[i*Len+j] = rand() % <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_data</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> Len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;Len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;Len; j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i*Len + j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Environment_Finalize</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_ms</span><span class="params">(<span class="keyword">int</span> rank, <span class="keyword">int</span> *a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(myrank == rank)</span><br><span class="line">	&#123;</span><br><span class="line">		send_i = myrank / sqrt_p;</span><br><span class="line">		send_j = myrank % sqrt_p;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sqrt_p; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i % sqrt_p != send_j)</span><br><span class="line">			&#123;</span><br><span class="line">				MPI_Send(a,stock*stock, MPI_INT, send_i*sqrt_p + i, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Recv(a,stock*stock, MPI_INT, rank, <span class="number">0</span>, MPI_COMM_WORLD, &amp;status);  </span><br><span class="line">	&#125;	</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *a, *b, *c;</span><br><span class="line">	<span class="keyword">int</span> u, v;</span><br><span class="line">	<span class="keyword">double</span> <span class="keyword">start_t</span>ime, <span class="keyword">end_t</span>ime;</span><br><span class="line">		</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	</span><br><span class="line">	MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">	MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</span><br><span class="line">	MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);</span><br><span class="line">  	</span><br><span class="line">	Len = <span class="number">10</span>;</span><br><span class="line">	sqrt_p = <span class="built_in">sqrt</span>(numprocs);</span><br><span class="line">	stock = Len / sqrt_p; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,stock);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//stock行的数据,每行的数据为stock,每个块间隔为len </span></span><br><span class="line">  	MPI_Type_vector(stock, stock, Len, MPI_INT, &amp;colum_data);  </span><br><span class="line">	MPI_Type_commit(&amp;colum_data);</span><br><span class="line">  	</span><br><span class="line">  	a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(stock*stock*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  	b = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(stock*stock*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	c = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(stock*stock*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  	buf = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(stock*Len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	</span><br><span class="line">  	<span class="keyword">if</span>(myrank == <span class="number">0</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">  		A = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(Len*Len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  		B = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(Len*Len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  		C = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(Len*Len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  		init_data(A, B, Len);</span><br><span class="line">  		</span><br><span class="line">		out_data(A,Len);</span><br><span class="line">  		</span><br><span class="line">  		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;stock; ++i)</span><br><span class="line">  		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;stock; ++j)</span><br><span class="line">  			a(i, j) = A(i, j);</span><br><span class="line">  			</span><br><span class="line">  		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;Len; i += stock)</span><br><span class="line">  		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;Len; j += stock)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">if</span>(i || j )</span><br><span class="line">  			&#123;</span><br><span class="line">  				MPI_Send(&amp;A(i,j), <span class="number">1</span>, colum_data,(i/stock)*sqrt_p + j/stock, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">  				MPI_Send(&amp;B(i,j), <span class="number">1</span>, colum_data, (i/stock)*sqrt_p + j/stock, <span class="number">1</span>, MPI_COMM_WORLD);</span><br><span class="line">  			&#125;</span><br><span class="line">	  	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Recv(buf, <span class="number">1</span>, colum_data, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;stock; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;stock; j++)</span><br><span class="line">				a(i, j) = buf[i*Len+j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MPI_Recv(buf, <span class="number">1</span>, colum_data, <span class="number">0</span>, <span class="number">1</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;stock; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;stock; j++)</span><br><span class="line">				b(i, j) = buf[i*Len+j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	MPI_Barrier(MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is rank %d\n"</span>, myrank);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;stock; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">  		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;stock; ++j)</span><br><span class="line">  			<span class="built_in">printf</span>(<span class="string">"%d "</span>, a(i,j));</span><br><span class="line">  			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//-------------------------------分配完毕--------------------------------------- </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(step = <span class="number">0</span>; step&lt;sqrt_p; step++)          <span class="comment">//执行sqrt(p)次迭代 </span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span>(step == <span class="number">0</span>)         <span class="comment">//第一步 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(myrank / sqrt_p == myrank % sqrt_p)</span><br><span class="line">			&#123;</span><br><span class="line">				send_m = myrank;</span><br><span class="line">			   	send_i = myrank / sqrt_p;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sqrt_p; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(send_m % sqrt_p != i)</span><br><span class="line">						MPI_Send(&amp;send_m, <span class="number">1</span>, MPI_INT, send_i * sqrt_p + i, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				send_i = myrank / sqrt_p;</span><br><span class="line">				MPI_Recv(&amp;send_m, <span class="number">1</span>, MPI_INT, send_i * sqrt_p + send_i, <span class="number">0</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">			&#125;	 </span><br><span class="line">			</span><br><span class="line">			send_ms(send_m, a);</span><br><span class="line">		</span><br><span class="line">			MPI_Barrier(MPI_COMM_WORLD);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">		clm(a, b, c, stock);             <span class="comment">//计算 </span></span><br><span class="line"> 	</span><br><span class="line">		     				    			<span class="comment">//第三步：B阵向上循环一步 </span></span><br><span class="line">		<span class="keyword">if</span>((myrank / sqrt_p) % <span class="number">2</span> == <span class="number">0</span>)      <span class="comment">//偶数进程先发送再接收 </span></span><br><span class="line">		&#123;</span><br><span class="line">			v = myrank / sqrt_p;</span><br><span class="line">			u = myrank % sqrt_p;</span><br><span class="line">			MPI_Send(b,stock*stock, MPI_INT, ((v - <span class="number">1</span> + sqrt_p) % sqrt_p) * sqrt_p + u, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">			MPI_Recv(buf,stock*stock, MPI_INT,((v + <span class="number">1</span>) % sqrt_p) * sqrt_p + u, <span class="number">0</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">			<span class="built_in">memcpy</span>(b,buf, <span class="keyword">sizeof</span>(stock*stock*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));      </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			v = myrank / sqrt_p;</span><br><span class="line">			u = myrank % sqrt_p;</span><br><span class="line">			MPI_Recv(buf,stock*stock, MPI_INT,((v + <span class="number">1</span>) % sqrt_p) * sqrt_p + u, <span class="number">0</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">			MPI_Send(b,stock*stock, MPI_INT, ((v - <span class="number">1</span> + sqrt_p) % sqrt_p) * sqrt_p + u, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">			<span class="built_in">memcpy</span>(b,buf, <span class="keyword">sizeof</span>(stock*stock*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(myrank == send_m)        <span class="comment">//第四步     </span></span><br><span class="line">		&#123; </span><br><span class="line">			   </span><br><span class="line"><span class="comment">//同一组中的，其他线程并不知道send_m改变了，怎么通知？</span></span><br><span class="line">			<span class="keyword">int</span> n;</span><br><span class="line">			n =  (myrank/sqrt_p)*sqrt_p + (myrank % sqrt_p + <span class="number">1</span>) % sqrt_p;      </span><br><span class="line"><span class="comment">//用上一次的主发送进程告诉其他人下次主发送进程改变了</span></span><br><span class="line">			send_i = send_m / sqrt_p;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sqrt_p; i++)</span><br><span class="line">			<span class="keyword">if</span>(send_m % sqrt_p != i)</span><br><span class="line">				MPI_Send(&amp;n,<span class="number">1</span>, MPI_INT, send_i * sqrt_p + i, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">			send_m = n;    </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			MPI_Recv(&amp;send_m,<span class="number">1</span>, MPI_INT, send_m, <span class="number">0</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		send_ms(send_m, a);</span><br><span class="line">		</span><br><span class="line">		MPI_Barrier(MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"> 		</span><br><span class="line"> 	<span class="comment">//-----------------------------------计算完成，收集结果---------------------------------------</span></span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">if</span>(myrank != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Send(c,stock*stock, MPI_INT, <span class="number">0</span>, myrank, MPI_COMM_WORLD);</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">if</span>(myrank == <span class="number">0</span>)</span><br><span class="line"> 	&#123;	</span><br><span class="line"> 		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;stock; i++)</span><br><span class="line"> 		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;stock; j++)</span><br><span class="line"> 		C(i,j) = c(i,j);</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;numprocs; i++)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			MPI_Recv(c,stock*stock, MPI_INT, i, i, MPI_COMM_WORLD, &amp;status);</span><br><span class="line"></span><br><span class="line">			v = i / sqrt_p;</span><br><span class="line">			u = i % sqrt_p;</span><br><span class="line">			</span><br><span class="line"> 			<span class="keyword">for</span>(j=v*stock; j&lt;(v+<span class="number">1</span>)*stock; j++)</span><br><span class="line"> 			<span class="keyword">for</span>(k=u*stock; k&lt;(u+<span class="number">1</span>)*stock; k++)</span><br><span class="line"> 			C(j,k) = c(j%stock,k%stock);</span><br><span class="line"> 		&#125;</span><br><span class="line">		</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">if</span>(myrank == <span class="number">0</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the result C muterix \n"</span>);</span><br><span class="line"> 		out_data(c, Len);</span><br><span class="line"> 		<span class="keyword">end_t</span>ime = MPI_Wtime();</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"the date M*M=%d p=%d cost time:%lf\n"</span>, Len, numprocs, <span class="keyword">end_t</span>ime-<span class="keyword">start_t</span>ime);</span><br><span class="line"> 	&#125;</span><br><span class="line">	 	</span><br><span class="line">	Environment_Finalize(a,b,c);</span><br><span class="line">	MPI_Finalize();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>Fox算法同样通过循环移位的办法来达到节省存储空间的目的。</p>]]>
    
    </summary>
    
      <category term="MPI" scheme="http://ylwhere.tk/tags/MPI/"/>
    
      <category term="parallel" scheme="http://ylwhere.tk/categories/parallel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[研究生这段日子的感受]]></title>
    <link href="http://ylwhere.tk/2014/11/22/yan-jiu-sheng-zhe-duan-ri-zi-de-gan-shou/"/>
    <id>http://ylwhere.tk/2014/11/22/yan-jiu-sheng-zhe-duan-ri-zi-de-gan-shou/</id>
    <published>2014-11-22T05:21:11.000Z</published>
    <updated>2015-05-22T14:19:05.894Z</updated>
    <content type="html"><![CDATA[<p>在科大读书也有些日子了，一直想写一个总结，却总是找不到一个合适的机会。<br>趁今天，写写感受吧，作为记录，也作为总结。<br><a id="more"></a></p>
<h2 id="1-_开学">1. 开学</h2><p>我记得自己是8月30号到的合肥。那天我没有要求父亲来科大送我，他是十分想来的，我知道。但是我觉得自己一个人就可以了，找个合适的机会吧。来科大那天下的小雨，我一个人从火车站赶到学校，在校园里找宿舍然后办理入住手续。当时的心情或许于那场雨类似吧。记得那雨断断续续的下了2天。合肥这边确实要比家里边下雨琴，或许是由于偏南的原因吧。总之，那几天对学校感觉如此的失望，尤其是我第一个到宿舍，还以为整个宿舍就我一个人住。(因为科大这边宿舍少，是插空入住式，也就是有空位就安排人住，所以很容易有的宿舍研一研二研三的都有。)后来知道了到了最后一天才知道我还有两个室友。当时感觉是如此的欣慰啊，原来这个宿舍并不是我一个新生，我并不孤单。</p>
<p>接下来当然是要买一系列的东西了，这就要说到我对这个地方越发的憎恨的第二原因了。这个二线城市的小合肥，这个经济还不如郑州的小地方。物价如此之高。（买一个洗澡巾要两位数）。没办法，入乡随俗咯，当时感觉以后的日子估计是惨淡的吧。</p>
<h2 id="2-_我的目标">2. 我的目标</h2><p>刚开始那几天，我一直在思考一个问题啊，我是什么的样人？我该怎么度过这三年？我以后又能干什么？思考是一件痛苦的事情，尤其是你发现结果其实并不那么明朗。我得出的结论是，我应该早些毕业，无论如何，我得对父母负责。希望他们早日能够享受平凡的幸福就可以了。其实他们对我的要求很简单，找份稳定的工作，早日结婚，让他们觉得他们可以早些放下自己身上的担子。因为在我的那个小村子，父母的责任就是为孩子置办了房子，然后看着自己的孩子结婚。他们就觉得安定下来了。当然，我的父母也是这样的人。</p>
<p>在这里，我是想感谢父亲和母亲大人对我的支持，无论，我这一路上选择怎么走，他们总是说，你自己选择吧。他们要做的，就是尽他们最大的努力，让我在以后的生活中，少些负担。我知道的，这一切我都是知道的，你们的努力，你们的坚持。我也知道你们也是着急了，我知道。感谢你们，谢谢你们的包容。</p>
<p>思维有些混乱，我也不知道会说到那里，就想着说着把。然后就是到了正常的选课开始上课的阶段。科大这边的有的课程会在一周的不同时间开设，比如说：算法，会在周一和周日同时开设。让同学们根据自己的时间，自己来安排哪一天来上课。我第一感觉到了研究生和本科的差异。科大这边研究生的数量比起其他学校来说并不多，而且我们生活在西区，西区教学楼只有一所。科大这边的老师上课还是很给力的。可是我发现，研究生老师上课，基本不会问：你们听懂了么？如果他问了，我会果断说：老师，我真的听不懂啊。研究生课程，课程设计的理论比较多，比如费马老先生的那么多定理。有人说，是先设计一个算法，然后才去分析他的复杂度的。不知道那些发明算法的老先生是否真的是这样的。科大这边的本科生教授算法的课本用的就是那本理论性最强的黑书：算法导论。我去旁听过一节课，确实是相当的不错。在这里，也推荐一本我读过的书，《数学之美》。是的，happiness with maths.</p>
<img src="/img/blog-img/maths.jpg">
<h2 id="3-_科大的生活">3. 科大的生活</h2><p>在说说科大的图书馆吧，这也是我对科大感情转变的地方，都说科大学习氛围好，如果不是去图书馆，我并没有了解到这个所谓的好，和我认识的有什么出入。科大西区的图书馆叫做档案馆，估计是因为西区图书馆里有些古老的书吧。这也是我后来发现的，科大的图书馆里有一排书，额，应该说是一排柜子，里面都是一张一张的卡片，用麻线穿起来的。里面的英文看起特别泛黄。它就坐落在那里。而且有意思的是，柜子上面的题头是：郑州二七纪念馆。科大的图书馆建筑确实比较老，当然，还不能和西交比(满墙的爬山虎)。第一次，去图书馆，确实让我感受到了科大的实力，因为他们都是看英文书，我看到那么小一个姑娘，在看一本数学的英文书，听到两个人在讨论一个方程的物理和数学意义。看到大部分人在看论文，在学雅思/托福。这时候我默默的把六级试卷拿了出来，看了周围他们在学雅思托福，我怀疑自己是不是来错教室的感觉。还有科大的图书馆里人真的很多，每次下午去都找不到座位，我感觉一定是因为图书馆里有暖气的原因。</p>
<img src="/img/blog-img/library.jpg">
<p>不知不觉中，对科大的感觉有了改变。因为一些温馨的细节吧，我觉得有一个英文单词，可以很好的形容。harmony，哈哈，感觉很和谐呢。</p>
<p>首先，是屌丝气质，科大这边，我基本上不用注意什么，因为在这里所有人关注的重点都不是衣服什么，把我扔在人群里完全找不到什么区别，因为大家都是这样，科大里流传着这样的一句话：大裤衩，富光杯。就是这样的节奏，这是我在郑大没有的感受，在郑大，一出宿舍，都是花花绿绿的妹子。。。。第二个，就是宿舍的楼管，在原来的宿舍，分分钟进进出出，大门都没有，不过现在突然有了宿管，大冬天的，那么冷，还在执勤，而且感觉合肥这边的人很好相处，无论他们身份如何。记得，一次开团课，同学们，直接喊：那个老师叫老大，而且讨论话题一点都不虚。举办运动会说计算机学院的妹子基本没人看，都去看管理学院和生院的妹子了。第三个小细节：就是，有次我去东区上EPC.就是研究生综合英文，因为六级没过，所以必须要上的，在图书馆休息的时候，睡过了，阿爷拍拍我，说：小伙子，快醒醒，要上课了。当时，心里一股暖流啊，他本没有必要那么做。在此，谢谢您了。</p>
<h2 id="4-_目前的状态">4. 目前的状态</h2><p>再次，说下目前的状态吧，导师说：研一这学期并不要求我们干活，先把课上好吧，打打基础。是的，因为觉得自己确实很差，可是老板说，虽然让打基础，却没有说让打什么基础。这也是一个坑啊。老板人很好，从来不管我们干什么，不像其他老板一样，天天让看论文，有利有弊吧，没办法，遇到了就是三年的时间呢。实验室的环境倒是不太好的，四四方方的屏幕，大概14寸吧，感觉是早该被抛弃的一代机器了，还好老板给我配了一个新的电脑，哈哈。</p>
<p>这几个月来，日子慢慢的适应了下来，偶尔和实验室的小伙伴一起吃饭，或者和室友们一起出去看电影。在科大，永远只有两个话题：科研和妹子。每天按时上课，作业按时教，交作业的本子是那种幼儿园小朋友用的本子，呵呵。</p>
<h2 id="5-_努力的方向">5. 努力的方向</h2><p>再谈谈另一个问题吧。我觉得它特别重要，那就是对自己的认识和自己的目标。人是要有目标的。在坐标轴上，如果你没有坐标目标点，你就不知道自己距离目标点还有多远，你就不知道该往哪个方向努力，是啊，时间是有价值的。没有目标就会迷茫，越来越觉得树立目标的重要性。但是，这却不是件容易的事情，就我来说，从小没有过什么目标之类的概念，你怎么要求我说几年以后会如何？第二个重要的时间中，就是在自己的生活中如何坚守自己，如何在自己孤独时不会放弃自己，那就是人要找到什么东西来支撑自己。火影上说：是对同伴的关心。每个人的方式都是不同的，关键是找到这种东西。当让我昨天看《星际穿越》，里面的一个物理学家为了等自己的同伴完成任务，他的同伴在另一个地方待了2个个多小时，可是他却在太空里等了23年。看到那个场面，感动到不行，一个人该是如何那么久的面对那份孤独。科研也是需要这种精神的吧。独山高楼，望尽天涯路。然后才会是衣带渐宽终不悔啊。</p>
<p>如果，如果我不是很着急的话，我是很像这科大读研的，这里的气氛给我一种做学位的地方。红砖并进，理实交融。我现在也有为了国家而做什么的理想。但是，10年以后，估计肯定不会有的。我所能作的，就是努力为了下一代而创造一个好一点的生活吧。好让，他以后想学什么，画画、舞蹈什么的，我都能养他。他想学习到什么时候都可以。</p>
<img src="/img/blog-img/pe1.jpg">
<p>上一辈的科大人已经完成了自己的使命，这一代还需要现在的人来创造，如果能够有任何机会来改变一部分，千万不要放弃自己的梦想。总之，科大还是比较好的，欢迎来这里读书，尤其本科生教育更好，本科宿舍没有网络。估计是学校怕本科生管不住自己吧，毕竟少年班的同学那么小。。真是感叹呐，从小都和别人有差距你还要怎样，种一棵树最好的时候是10年以前。</p>
<h2 id="5-_总结">5. 总结</h2><p>总结，说的比较凌乱，原来想写的时候不是这些的。哎，思维总是跳跃的。总之，我在这里很好，同志们，要找到慰藉自己的东西，珍惜！</p>
<p>2014年-11月-22日。</p>
<p>写于科大西区宿舍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在科大读书也有些日子了，一直想写一个总结，却总是找不到一个合适的机会。<br>趁今天，写写感受吧，作为记录，也作为总结。<br>]]>
    
    </summary>
    
      <category term="心路札记" scheme="http://ylwhere.tk/categories/%E5%BF%83%E8%B7%AF%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MPI 实现流水线模型]]></title>
    <link href="http://ylwhere.tk/2014/11/13/MPI-%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%A8%A1%E5%9E%8B/"/>
    <id>http://ylwhere.tk/2014/11/13/MPI-实现流水线模型/</id>
    <published>2014-11-13T15:38:34.000Z</published>
    <updated>2015-06-02T23:55:55.620Z</updated>
    <content type="html"><![CDATA[<p>cpu在单处理器执行指令时，采用的是流水线模型。在一个流水线多次执行时可以加速。<br>超标量介于标量和向量之间，因为处理器处理一条指令：去指令，解析/取数，计算/写数五步。<br>而随着其他算数部件，例如ALU和PLU的增加，标量的话会令处理器的处理性能降低，而有些机器和操作却并不支持向量操作。而多处理器同样可以加速指令的执行速度，在每个指令处理的过程中依然是超标量的，也就是多条流水线。<br><a id="more"></a></p>
<p>顺便整理了一些资料：</p>
<p>MIMD既可以共享内存也可以每个处理器独享内存，共享内存的好处是操作系统维护内存患处是：不宜扩充、不灵活。</p>
<p>目前大致知道了，什么是simp,mimp,一些体系结构的知识。</p>
<p>下面给个wiki上的一个链接：<br><a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline" target="_blank" rel="external">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a></p>
<figure class="highlight c"><figcaption><span>pipeline.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// the pipeline funtion like the RISC pipeline</span></span><br><span class="line"><span class="comment">//wyl </span></span><br><span class="line"><span class="comment">// code maybe a[i] = a[i-1] </span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "mpi.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Len 4000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j, M, N;  <span class="comment">// MΪɎϱט¸´µĴϊ</span></span><br><span class="line"><span class="keyword">int</span> root, perce; <span class="comment">// perce = Len / numprocs</span></span><br><span class="line"><span class="keyword">int</span> data[Len];</span><br><span class="line"><span class="keyword">int</span> myrank, numproncs;</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">get_key</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ++key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	MPI_Init(&amp;argc, &amp;argv);	</span><br><span class="line">	MPI_Comm_size(MPI_COMM_WORLD, &amp;numproncs);</span><br><span class="line"></span><br><span class="line">	M = <span class="number">10000</span>;</span><br><span class="line">	root = <span class="number">0</span>;</span><br><span class="line">	perce = <span class="built_in">floor</span>((Len / numproncs) + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		data[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	MPI_Finalize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Single_computer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>; j &lt; Len; j++)</span><br><span class="line">	data[j] = data[j-<span class="number">1</span>] + get_key();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dump_computer</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(myrank == root)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> start = perce * myrank;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = start; j &lt; start + perce; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				data[j] = data[j-<span class="number">1</span>] + get_key();</span><br><span class="line">			&#125;</span><br><span class="line">			MPI_Send(&amp;data[j-<span class="number">1</span>], <span class="number">1</span>, MPI_INT, myrank+<span class="number">1</span>, i, MPI_COMM_WORLD);   <span class="comment">//лϢ±뇩i±°´Ѳµ½´</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( myrank != root &amp;&amp; myrank &lt;(numproncs-<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> start = perce * myrank;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			MPI_Recv(&amp;data[myrank*perce-<span class="number">1</span>], <span class="number">1</span>, MPI_INT, myrank-<span class="number">1</span>, i, MPI_COMM_WORLD, &amp;status);		</span><br><span class="line">			<span class="keyword">for</span>(j = start; j &lt; start + perce; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				data[j] = data[j-<span class="number">1</span>] + get_key();</span><br><span class="line">			&#125;</span><br><span class="line">			MPI_Send(&amp;data[j-<span class="number">1</span>], <span class="number">1</span>, MPI_INT, myrank+<span class="number">1</span>, i, MPI_COMM_WORLD);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(myrank == numproncs - <span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">int</span> start = perce * myrank;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			MPI_Recv(&amp;data[start-<span class="number">1</span>], <span class="number">1</span>, MPI_INT, myrank-<span class="number">1</span>, i, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">			<span class="keyword">for</span>(j = start; j &lt; start + perce &amp;&amp; j &lt; Len; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				data[j] = data[j-<span class="number">1</span>] + get_key();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> start, end;</span><br><span class="line"></span><br><span class="line">	init(argc, argv);</span><br><span class="line">	</span><br><span class="line">	start = MPI_Wtime();</span><br><span class="line">	<span class="keyword">if</span>(numproncs == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Single_computer();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Dump_computer();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	end = MPI_Wtime();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(numproncs == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the Single thread running %lf s\n"</span>, end - start);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(myrank == numproncs - <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the total %d threads runing %lf s\n"</span>, numproncs, end -start);</span><br><span class="line"></span><br><span class="line">	Finalize();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>cpu在单处理器执行指令时，采用的是流水线模型。在一个流水线多次执行时可以加速。<br>超标量介于标量和向量之间，因为处理器处理一条指令：去指令，解析/取数，计算/写数五步。<br>而随着其他算数部件，例如ALU和PLU的增加，标量的话会令处理器的处理性能降低，而有些机器和操作却并不支持向量操作。而多处理器同样可以加速指令的执行速度，在每个指令处理的过程中依然是超标量的，也就是多条流水线。<br>]]>
    
    </summary>
    
      <category term="MPI" scheme="http://ylwhere.tk/tags/MPI/"/>
    
      <category term="parallel" scheme="http://ylwhere.tk/categories/parallel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++ explicit构造函数]]></title>
    <link href="http://ylwhere.tk/2014/11/12/c++-explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://ylwhere.tk/2014/11/12/c++-explicit构造函数/</id>
    <published>2014-11-11T17:08:43.000Z</published>
    <updated>2015-05-22T14:45:54.701Z</updated>
    <content type="html"><![CDATA[<p>当c++的构造函数只有一个参数时，有时候在表达式运算时会调用c++隐式转换，生成一个临时对象。<br>按照默认规定，只有一个参数的构造函数也定义了一个隐式转换，将该构造函数对应数据类型的数据转换为该类对象。</p>
<a id="more"></a>
<p>下面的代码是没有加explicit关键字，可以编译运行，默认会调用A的单参数构造函数，但是加了explicit就会编译错误。</p>
<p>隐式转换的坏处就是有可能会发生错误，令程序很难调试，第二就是会生成临时对象，增加构造和析构的负担。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	A(<span class="keyword">int</span> value)   <span class="comment">//没有explicit</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A(A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;value = a.value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::endl;	</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A a = <span class="number">2</span>;    <span class="comment">//调用隐式转换</span></span><br><span class="line"></span><br><span class="line">	a.print();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请记住：</p>
<p>提防隐式转换所带来的微妙问题，尽量控制隐式转换的发生；通常采用的方式包括：  </p>
<ol>
<li>使用非C/C++关键字的具名函数，用operator as_T()替换operato T()（T为C++数据类型）。  </li>
<li>为单参数的构造函数加上explicit关键字。</li>
</ol>
<p><strong><em>参考：</em></strong></p>
<p><a href="http://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html" target="_blank" rel="external">http://www.cnblogs.com/cutepig/archive/2009/01/14/1375917.html</a><br><a href="http://book.51cto.com/art/201202/317579.htm" target="_blank" rel="external">http://book.51cto.com/art/201202/317579.htm</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当c++的构造函数只有一个参数时，有时候在表达式运算时会调用c++隐式转换，生成一个临时对象。<br>按照默认规定，只有一个参数的构造函数也定义了一个隐式转换，将该构造函数对应数据类型的数据转换为该类对象。</p>]]>
    
    </summary>
    
      <category term="C/C++" scheme="http://ylwhere.tk/tags/C-C/"/>
    
      <category term="C/C++" scheme="http://ylwhere.tk/categories/C-C/"/>
    
  </entry>
  
</feed>